// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AlProtocol.proto

#ifndef PROTOBUF_AlProtocol_2eproto__INCLUDED
#define PROTOBUF_AlProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace AlProto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AlProtocol_2eproto();
void protobuf_AssignDesc_AlProtocol_2eproto();
void protobuf_ShutdownFile_AlProtocol_2eproto();

class GpuResourceInfo;
class ResourceInfo;
class FrameworkIDInfo;
class FrameworkInstanceInfo;
class StartRootModule;
class AssignResourceInfo;
class ActualResourceInfo;
class AssignAndActualResourceInfo;
class PlatformAndMachineResouceInfo;
class ApplyAndUseResourceInfo;
class MachineInstanceResourceInfo;
class InstanceMachineResourceInfo;
class AllFrameworkResourceInfo;
class AllMachineResourceInfo;
class FrameworkInstanceResourceInfo;
class GetBusinessEntry;
class GetBusinessEntryAck;

// ===================================================================

class GpuResourceInfo : public ::google::protobuf::Message {
 public:
  GpuResourceInfo();
  virtual ~GpuResourceInfo();

  GpuResourceInfo(const GpuResourceInfo& from);

  inline GpuResourceInfo& operator=(const GpuResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GpuResourceInfo& default_instance();

  void Swap(GpuResourceInfo* other);

  // implements Message ----------------------------------------------

  GpuResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpuResourceInfo& from);
  void MergeFrom(const GpuResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string gpu_name = 1;
  inline bool has_gpu_name() const;
  inline void clear_gpu_name();
  static const int kGpuNameFieldNumber = 1;
  inline const ::std::string& gpu_name() const;
  inline void set_gpu_name(const ::std::string& value);
  inline void set_gpu_name(const char* value);
  inline void set_gpu_name(const char* value, size_t size);
  inline ::std::string* mutable_gpu_name();
  inline ::std::string* release_gpu_name();
  inline void set_allocated_gpu_name(::std::string* gpu_name);

  // optional uint32 gpu_mem_size = 2;
  inline bool has_gpu_mem_size() const;
  inline void clear_gpu_mem_size();
  static const int kGpuMemSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 gpu_mem_size() const;
  inline void set_gpu_mem_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AlProto.GpuResourceInfo)
 private:
  inline void set_has_gpu_name();
  inline void clear_has_gpu_name();
  inline void set_has_gpu_mem_size();
  inline void clear_has_gpu_mem_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gpu_name_;
  ::google::protobuf::uint32 gpu_mem_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static GpuResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResourceInfo : public ::google::protobuf::Message {
 public:
  ResourceInfo();
  virtual ~ResourceInfo();

  ResourceInfo(const ResourceInfo& from);

  inline ResourceInfo& operator=(const ResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceInfo& default_instance();

  void Swap(ResourceInfo* other);

  // implements Message ----------------------------------------------

  ResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceInfo& from);
  void MergeFrom(const ResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double cpu_num = 1;
  inline bool has_cpu_num() const;
  inline void clear_cpu_num();
  static const int kCpuNumFieldNumber = 1;
  inline double cpu_num() const;
  inline void set_cpu_num(double value);

  // required uint32 cpu_mem_size = 2;
  inline bool has_cpu_mem_size() const;
  inline void clear_cpu_mem_size();
  static const int kCpuMemSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 cpu_mem_size() const;
  inline void set_cpu_mem_size(::google::protobuf::uint32 value);

  // optional uint32 gpu_num = 3;
  inline bool has_gpu_num() const;
  inline void clear_gpu_num();
  static const int kGpuNumFieldNumber = 3;
  inline ::google::protobuf::uint32 gpu_num() const;
  inline void set_gpu_num(::google::protobuf::uint32 value);

  // repeated .AlProto.GpuResourceInfo gpu_resource_info = 4;
  inline int gpu_resource_info_size() const;
  inline void clear_gpu_resource_info();
  static const int kGpuResourceInfoFieldNumber = 4;
  inline const ::AlProto::GpuResourceInfo& gpu_resource_info(int index) const;
  inline ::AlProto::GpuResourceInfo* mutable_gpu_resource_info(int index);
  inline ::AlProto::GpuResourceInfo* add_gpu_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::AlProto::GpuResourceInfo >&
      gpu_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::AlProto::GpuResourceInfo >*
      mutable_gpu_resource_info();

  // @@protoc_insertion_point(class_scope:AlProto.ResourceInfo)
 private:
  inline void set_has_cpu_num();
  inline void clear_has_cpu_num();
  inline void set_has_cpu_mem_size();
  inline void clear_has_cpu_mem_size();
  inline void set_has_gpu_num();
  inline void clear_has_gpu_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double cpu_num_;
  ::google::protobuf::uint32 cpu_mem_size_;
  ::google::protobuf::uint32 gpu_num_;
  ::google::protobuf::RepeatedPtrField< ::AlProto::GpuResourceInfo > gpu_resource_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static ResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkIDInfo : public ::google::protobuf::Message {
 public:
  FrameworkIDInfo();
  virtual ~FrameworkIDInfo();

  FrameworkIDInfo(const FrameworkIDInfo& from);

  inline FrameworkIDInfo& operator=(const FrameworkIDInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkIDInfo& default_instance();

  void Swap(FrameworkIDInfo* other);

  // implements Message ----------------------------------------------

  FrameworkIDInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkIDInfo& from);
  void MergeFrom(const FrameworkIDInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_id() const;
  inline void set_framework_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AlProto.FrameworkIDInfo)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 framework_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static FrameworkIDInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInstanceInfo : public ::google::protobuf::Message {
 public:
  FrameworkInstanceInfo();
  virtual ~FrameworkInstanceInfo();

  FrameworkInstanceInfo(const FrameworkInstanceInfo& from);

  inline FrameworkInstanceInfo& operator=(const FrameworkInstanceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInstanceInfo& default_instance();

  void Swap(FrameworkInstanceInfo* other);

  // implements Message ----------------------------------------------

  FrameworkInstanceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInstanceInfo& from);
  void MergeFrom(const FrameworkInstanceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_id() const;
  inline void set_framework_id(::google::protobuf::uint32 value);

  // required uint32 framework_instance_id = 2;
  inline bool has_framework_instance_id() const;
  inline void clear_framework_instance_id();
  static const int kFrameworkInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 framework_instance_id() const;
  inline void set_framework_instance_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AlProto.FrameworkInstanceInfo)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_framework_instance_id();
  inline void clear_has_framework_instance_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 framework_id_;
  ::google::protobuf::uint32 framework_instance_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static FrameworkInstanceInfo* default_instance_;
};
// -------------------------------------------------------------------

class StartRootModule : public ::google::protobuf::Message {
 public:
  StartRootModule();
  virtual ~StartRootModule();

  StartRootModule(const StartRootModule& from);

  inline StartRootModule& operator=(const StartRootModule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartRootModule& default_instance();

  void Swap(StartRootModule* other);

  // implements Message ----------------------------------------------

  StartRootModule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartRootModule& from);
  void MergeFrom(const StartRootModule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_id() const;
  inline void set_framework_id(::google::protobuf::uint32 value);

  // optional string image_lable = 2;
  inline bool has_image_lable() const;
  inline void clear_image_lable();
  static const int kImageLableFieldNumber = 2;
  inline const ::std::string& image_lable() const;
  inline void set_image_lable(const ::std::string& value);
  inline void set_image_lable(const char* value);
  inline void set_image_lable(const char* value, size_t size);
  inline ::std::string* mutable_image_lable();
  inline ::std::string* release_image_lable();
  inline void set_allocated_image_lable(::std::string* image_lable);

  // optional string module_name = 3;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 3;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  inline void set_allocated_module_name(::std::string* module_name);

  // optional string location_file_path = 4;
  inline bool has_location_file_path() const;
  inline void clear_location_file_path();
  static const int kLocationFilePathFieldNumber = 4;
  inline const ::std::string& location_file_path() const;
  inline void set_location_file_path(const ::std::string& value);
  inline void set_location_file_path(const char* value);
  inline void set_location_file_path(const char* value, size_t size);
  inline ::std::string* mutable_location_file_path();
  inline ::std::string* release_location_file_path();
  inline void set_allocated_location_file_path(::std::string* location_file_path);

  // required string nc_ip = 5;
  inline bool has_nc_ip() const;
  inline void clear_nc_ip();
  static const int kNcIpFieldNumber = 5;
  inline const ::std::string& nc_ip() const;
  inline void set_nc_ip(const ::std::string& value);
  inline void set_nc_ip(const char* value);
  inline void set_nc_ip(const char* value, size_t size);
  inline ::std::string* mutable_nc_ip();
  inline ::std::string* release_nc_ip();
  inline void set_allocated_nc_ip(::std::string* nc_ip);

  // optional .AlProto.ResourceInfo request_resource_size = 6;
  inline bool has_request_resource_size() const;
  inline void clear_request_resource_size();
  static const int kRequestResourceSizeFieldNumber = 6;
  inline const ::AlProto::ResourceInfo& request_resource_size() const;
  inline ::AlProto::ResourceInfo* mutable_request_resource_size();
  inline ::AlProto::ResourceInfo* release_request_resource_size();
  inline void set_allocated_request_resource_size(::AlProto::ResourceInfo* request_resource_size);

  // optional uint32 listen_num = 7;
  inline bool has_listen_num() const;
  inline void clear_listen_num();
  static const int kListenNumFieldNumber = 7;
  inline ::google::protobuf::uint32 listen_num() const;
  inline void set_listen_num(::google::protobuf::uint32 value);

  // optional .AlProto.ResourceInfo framework_max_request_resource_size = 8;
  inline bool has_framework_max_request_resource_size() const;
  inline void clear_framework_max_request_resource_size();
  static const int kFrameworkMaxRequestResourceSizeFieldNumber = 8;
  inline const ::AlProto::ResourceInfo& framework_max_request_resource_size() const;
  inline ::AlProto::ResourceInfo* mutable_framework_max_request_resource_size();
  inline ::AlProto::ResourceInfo* release_framework_max_request_resource_size();
  inline void set_allocated_framework_max_request_resource_size(::AlProto::ResourceInfo* framework_max_request_resource_size);

  // @@protoc_insertion_point(class_scope:AlProto.StartRootModule)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_image_lable();
  inline void clear_has_image_lable();
  inline void set_has_module_name();
  inline void clear_has_module_name();
  inline void set_has_location_file_path();
  inline void clear_has_location_file_path();
  inline void set_has_nc_ip();
  inline void clear_has_nc_ip();
  inline void set_has_request_resource_size();
  inline void clear_has_request_resource_size();
  inline void set_has_listen_num();
  inline void clear_has_listen_num();
  inline void set_has_framework_max_request_resource_size();
  inline void clear_has_framework_max_request_resource_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* image_lable_;
  ::std::string* module_name_;
  ::std::string* location_file_path_;
  ::google::protobuf::uint32 framework_id_;
  ::google::protobuf::uint32 listen_num_;
  ::std::string* nc_ip_;
  ::AlProto::ResourceInfo* request_resource_size_;
  ::AlProto::ResourceInfo* framework_max_request_resource_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static StartRootModule* default_instance_;
};
// -------------------------------------------------------------------

class AssignResourceInfo : public ::google::protobuf::Message {
 public:
  AssignResourceInfo();
  virtual ~AssignResourceInfo();

  AssignResourceInfo(const AssignResourceInfo& from);

  inline AssignResourceInfo& operator=(const AssignResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignResourceInfo& default_instance();

  void Swap(AssignResourceInfo* other);

  // implements Message ----------------------------------------------

  AssignResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssignResourceInfo& from);
  void MergeFrom(const AssignResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AlProto.ResourceInfo total_have_resource = 1;
  inline bool has_total_have_resource() const;
  inline void clear_total_have_resource();
  static const int kTotalHaveResourceFieldNumber = 1;
  inline const ::AlProto::ResourceInfo& total_have_resource() const;
  inline ::AlProto::ResourceInfo* mutable_total_have_resource();
  inline ::AlProto::ResourceInfo* release_total_have_resource();
  inline void set_allocated_total_have_resource(::AlProto::ResourceInfo* total_have_resource);

  // optional .AlProto.ResourceInfo total_not_assign_resource = 2;
  inline bool has_total_not_assign_resource() const;
  inline void clear_total_not_assign_resource();
  static const int kTotalNotAssignResourceFieldNumber = 2;
  inline const ::AlProto::ResourceInfo& total_not_assign_resource() const;
  inline ::AlProto::ResourceInfo* mutable_total_not_assign_resource();
  inline ::AlProto::ResourceInfo* release_total_not_assign_resource();
  inline void set_allocated_total_not_assign_resource(::AlProto::ResourceInfo* total_not_assign_resource);

  // optional .AlProto.ResourceInfo total_already_assign_resource = 3;
  inline bool has_total_already_assign_resource() const;
  inline void clear_total_already_assign_resource();
  static const int kTotalAlreadyAssignResourceFieldNumber = 3;
  inline const ::AlProto::ResourceInfo& total_already_assign_resource() const;
  inline ::AlProto::ResourceInfo* mutable_total_already_assign_resource();
  inline ::AlProto::ResourceInfo* release_total_already_assign_resource();
  inline void set_allocated_total_already_assign_resource(::AlProto::ResourceInfo* total_already_assign_resource);

  // @@protoc_insertion_point(class_scope:AlProto.AssignResourceInfo)
 private:
  inline void set_has_total_have_resource();
  inline void clear_has_total_have_resource();
  inline void set_has_total_not_assign_resource();
  inline void clear_has_total_not_assign_resource();
  inline void set_has_total_already_assign_resource();
  inline void clear_has_total_already_assign_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AlProto::ResourceInfo* total_have_resource_;
  ::AlProto::ResourceInfo* total_not_assign_resource_;
  ::AlProto::ResourceInfo* total_already_assign_resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static AssignResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ActualResourceInfo : public ::google::protobuf::Message {
 public:
  ActualResourceInfo();
  virtual ~ActualResourceInfo();

  ActualResourceInfo(const ActualResourceInfo& from);

  inline ActualResourceInfo& operator=(const ActualResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActualResourceInfo& default_instance();

  void Swap(ActualResourceInfo* other);

  // implements Message ----------------------------------------------

  ActualResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActualResourceInfo& from);
  void MergeFrom(const ActualResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AlProto.ResourceInfo total_use_resource = 1;
  inline bool has_total_use_resource() const;
  inline void clear_total_use_resource();
  static const int kTotalUseResourceFieldNumber = 1;
  inline const ::AlProto::ResourceInfo& total_use_resource() const;
  inline ::AlProto::ResourceInfo* mutable_total_use_resource();
  inline ::AlProto::ResourceInfo* release_total_use_resource();
  inline void set_allocated_total_use_resource(::AlProto::ResourceInfo* total_use_resource);

  // optional .AlProto.ResourceInfo total_not_use_resource = 2;
  inline bool has_total_not_use_resource() const;
  inline void clear_total_not_use_resource();
  static const int kTotalNotUseResourceFieldNumber = 2;
  inline const ::AlProto::ResourceInfo& total_not_use_resource() const;
  inline ::AlProto::ResourceInfo* mutable_total_not_use_resource();
  inline ::AlProto::ResourceInfo* release_total_not_use_resource();
  inline void set_allocated_total_not_use_resource(::AlProto::ResourceInfo* total_not_use_resource);

  // @@protoc_insertion_point(class_scope:AlProto.ActualResourceInfo)
 private:
  inline void set_has_total_use_resource();
  inline void clear_has_total_use_resource();
  inline void set_has_total_not_use_resource();
  inline void clear_has_total_not_use_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AlProto::ResourceInfo* total_use_resource_;
  ::AlProto::ResourceInfo* total_not_use_resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static ActualResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class AssignAndActualResourceInfo : public ::google::protobuf::Message {
 public:
  AssignAndActualResourceInfo();
  virtual ~AssignAndActualResourceInfo();

  AssignAndActualResourceInfo(const AssignAndActualResourceInfo& from);

  inline AssignAndActualResourceInfo& operator=(const AssignAndActualResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignAndActualResourceInfo& default_instance();

  void Swap(AssignAndActualResourceInfo* other);

  // implements Message ----------------------------------------------

  AssignAndActualResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssignAndActualResourceInfo& from);
  void MergeFrom(const AssignAndActualResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AlProto.AssignResourceInfo assign_resource = 1;
  inline bool has_assign_resource() const;
  inline void clear_assign_resource();
  static const int kAssignResourceFieldNumber = 1;
  inline const ::AlProto::AssignResourceInfo& assign_resource() const;
  inline ::AlProto::AssignResourceInfo* mutable_assign_resource();
  inline ::AlProto::AssignResourceInfo* release_assign_resource();
  inline void set_allocated_assign_resource(::AlProto::AssignResourceInfo* assign_resource);

  // optional .AlProto.ActualResourceInfo actual_resource = 2;
  inline bool has_actual_resource() const;
  inline void clear_actual_resource();
  static const int kActualResourceFieldNumber = 2;
  inline const ::AlProto::ActualResourceInfo& actual_resource() const;
  inline ::AlProto::ActualResourceInfo* mutable_actual_resource();
  inline ::AlProto::ActualResourceInfo* release_actual_resource();
  inline void set_allocated_actual_resource(::AlProto::ActualResourceInfo* actual_resource);

  // @@protoc_insertion_point(class_scope:AlProto.AssignAndActualResourceInfo)
 private:
  inline void set_has_assign_resource();
  inline void clear_has_assign_resource();
  inline void set_has_actual_resource();
  inline void clear_has_actual_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AlProto::AssignResourceInfo* assign_resource_;
  ::AlProto::ActualResourceInfo* actual_resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static AssignAndActualResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlatformAndMachineResouceInfo : public ::google::protobuf::Message {
 public:
  PlatformAndMachineResouceInfo();
  virtual ~PlatformAndMachineResouceInfo();

  PlatformAndMachineResouceInfo(const PlatformAndMachineResouceInfo& from);

  inline PlatformAndMachineResouceInfo& operator=(const PlatformAndMachineResouceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlatformAndMachineResouceInfo& default_instance();

  void Swap(PlatformAndMachineResouceInfo* other);

  // implements Message ----------------------------------------------

  PlatformAndMachineResouceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlatformAndMachineResouceInfo& from);
  void MergeFrom(const PlatformAndMachineResouceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AlProto.AssignAndActualResourceInfo platform_resource = 1;
  inline bool has_platform_resource() const;
  inline void clear_platform_resource();
  static const int kPlatformResourceFieldNumber = 1;
  inline const ::AlProto::AssignAndActualResourceInfo& platform_resource() const;
  inline ::AlProto::AssignAndActualResourceInfo* mutable_platform_resource();
  inline ::AlProto::AssignAndActualResourceInfo* release_platform_resource();
  inline void set_allocated_platform_resource(::AlProto::AssignAndActualResourceInfo* platform_resource);

  // repeated .AlProto.AssignAndActualResourceInfo machine_resource = 2;
  inline int machine_resource_size() const;
  inline void clear_machine_resource();
  static const int kMachineResourceFieldNumber = 2;
  inline const ::AlProto::AssignAndActualResourceInfo& machine_resource(int index) const;
  inline ::AlProto::AssignAndActualResourceInfo* mutable_machine_resource(int index);
  inline ::AlProto::AssignAndActualResourceInfo* add_machine_resource();
  inline const ::google::protobuf::RepeatedPtrField< ::AlProto::AssignAndActualResourceInfo >&
      machine_resource() const;
  inline ::google::protobuf::RepeatedPtrField< ::AlProto::AssignAndActualResourceInfo >*
      mutable_machine_resource();

  // @@protoc_insertion_point(class_scope:AlProto.PlatformAndMachineResouceInfo)
 private:
  inline void set_has_platform_resource();
  inline void clear_has_platform_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AlProto::AssignAndActualResourceInfo* platform_resource_;
  ::google::protobuf::RepeatedPtrField< ::AlProto::AssignAndActualResourceInfo > machine_resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlatformAndMachineResouceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ApplyAndUseResourceInfo : public ::google::protobuf::Message {
 public:
  ApplyAndUseResourceInfo();
  virtual ~ApplyAndUseResourceInfo();

  ApplyAndUseResourceInfo(const ApplyAndUseResourceInfo& from);

  inline ApplyAndUseResourceInfo& operator=(const ApplyAndUseResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyAndUseResourceInfo& default_instance();

  void Swap(ApplyAndUseResourceInfo* other);

  // implements Message ----------------------------------------------

  ApplyAndUseResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyAndUseResourceInfo& from);
  void MergeFrom(const ApplyAndUseResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AlProto.ResourceInfo apply_resource = 1;
  inline bool has_apply_resource() const;
  inline void clear_apply_resource();
  static const int kApplyResourceFieldNumber = 1;
  inline const ::AlProto::ResourceInfo& apply_resource() const;
  inline ::AlProto::ResourceInfo* mutable_apply_resource();
  inline ::AlProto::ResourceInfo* release_apply_resource();
  inline void set_allocated_apply_resource(::AlProto::ResourceInfo* apply_resource);

  // optional .AlProto.ResourceInfo use_resource = 2;
  inline bool has_use_resource() const;
  inline void clear_use_resource();
  static const int kUseResourceFieldNumber = 2;
  inline const ::AlProto::ResourceInfo& use_resource() const;
  inline ::AlProto::ResourceInfo* mutable_use_resource();
  inline ::AlProto::ResourceInfo* release_use_resource();
  inline void set_allocated_use_resource(::AlProto::ResourceInfo* use_resource);

  // @@protoc_insertion_point(class_scope:AlProto.ApplyAndUseResourceInfo)
 private:
  inline void set_has_apply_resource();
  inline void clear_has_apply_resource();
  inline void set_has_use_resource();
  inline void clear_has_use_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AlProto::ResourceInfo* apply_resource_;
  ::AlProto::ResourceInfo* use_resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static ApplyAndUseResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MachineInstanceResourceInfo : public ::google::protobuf::Message {
 public:
  MachineInstanceResourceInfo();
  virtual ~MachineInstanceResourceInfo();

  MachineInstanceResourceInfo(const MachineInstanceResourceInfo& from);

  inline MachineInstanceResourceInfo& operator=(const MachineInstanceResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineInstanceResourceInfo& default_instance();

  void Swap(MachineInstanceResourceInfo* other);

  // implements Message ----------------------------------------------

  MachineInstanceResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MachineInstanceResourceInfo& from);
  void MergeFrom(const MachineInstanceResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nc_ip = 1;
  inline bool has_nc_ip() const;
  inline void clear_nc_ip();
  static const int kNcIpFieldNumber = 1;
  inline const ::std::string& nc_ip() const;
  inline void set_nc_ip(const ::std::string& value);
  inline void set_nc_ip(const char* value);
  inline void set_nc_ip(const char* value, size_t size);
  inline ::std::string* mutable_nc_ip();
  inline ::std::string* release_nc_ip();
  inline void set_allocated_nc_ip(::std::string* nc_ip);

  // optional .AlProto.ApplyAndUseResourceInfo machine_apply_use_resource = 2;
  inline bool has_machine_apply_use_resource() const;
  inline void clear_machine_apply_use_resource();
  static const int kMachineApplyUseResourceFieldNumber = 2;
  inline const ::AlProto::ApplyAndUseResourceInfo& machine_apply_use_resource() const;
  inline ::AlProto::ApplyAndUseResourceInfo* mutable_machine_apply_use_resource();
  inline ::AlProto::ApplyAndUseResourceInfo* release_machine_apply_use_resource();
  inline void set_allocated_machine_apply_use_resource(::AlProto::ApplyAndUseResourceInfo* machine_apply_use_resource);

  // @@protoc_insertion_point(class_scope:AlProto.MachineInstanceResourceInfo)
 private:
  inline void set_has_nc_ip();
  inline void clear_has_nc_ip();
  inline void set_has_machine_apply_use_resource();
  inline void clear_has_machine_apply_use_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nc_ip_;
  ::AlProto::ApplyAndUseResourceInfo* machine_apply_use_resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static MachineInstanceResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class InstanceMachineResourceInfo : public ::google::protobuf::Message {
 public:
  InstanceMachineResourceInfo();
  virtual ~InstanceMachineResourceInfo();

  InstanceMachineResourceInfo(const InstanceMachineResourceInfo& from);

  inline InstanceMachineResourceInfo& operator=(const InstanceMachineResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceMachineResourceInfo& default_instance();

  void Swap(InstanceMachineResourceInfo* other);

  // implements Message ----------------------------------------------

  InstanceMachineResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceMachineResourceInfo& from);
  void MergeFrom(const InstanceMachineResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 framework_instance_id = 1;
  inline bool has_framework_instance_id() const;
  inline void clear_framework_instance_id();
  static const int kFrameworkInstanceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_instance_id() const;
  inline void set_framework_instance_id(::google::protobuf::uint32 value);

  // optional .AlProto.ApplyAndUseResourceInfo instance_apply_use_resource = 2;
  inline bool has_instance_apply_use_resource() const;
  inline void clear_instance_apply_use_resource();
  static const int kInstanceApplyUseResourceFieldNumber = 2;
  inline const ::AlProto::ApplyAndUseResourceInfo& instance_apply_use_resource() const;
  inline ::AlProto::ApplyAndUseResourceInfo* mutable_instance_apply_use_resource();
  inline ::AlProto::ApplyAndUseResourceInfo* release_instance_apply_use_resource();
  inline void set_allocated_instance_apply_use_resource(::AlProto::ApplyAndUseResourceInfo* instance_apply_use_resource);

  // @@protoc_insertion_point(class_scope:AlProto.InstanceMachineResourceInfo)
 private:
  inline void set_has_framework_instance_id();
  inline void clear_has_framework_instance_id();
  inline void set_has_instance_apply_use_resource();
  inline void clear_has_instance_apply_use_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AlProto::ApplyAndUseResourceInfo* instance_apply_use_resource_;
  ::google::protobuf::uint32 framework_instance_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static InstanceMachineResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class AllFrameworkResourceInfo : public ::google::protobuf::Message {
 public:
  AllFrameworkResourceInfo();
  virtual ~AllFrameworkResourceInfo();

  AllFrameworkResourceInfo(const AllFrameworkResourceInfo& from);

  inline AllFrameworkResourceInfo& operator=(const AllFrameworkResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllFrameworkResourceInfo& default_instance();

  void Swap(AllFrameworkResourceInfo* other);

  // implements Message ----------------------------------------------

  AllFrameworkResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllFrameworkResourceInfo& from);
  void MergeFrom(const AllFrameworkResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 framework_instance_id = 1;
  inline bool has_framework_instance_id() const;
  inline void clear_framework_instance_id();
  static const int kFrameworkInstanceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_instance_id() const;
  inline void set_framework_instance_id(::google::protobuf::uint32 value);

  // optional .AlProto.ApplyAndUseResourceInfo instance_total_apply_use_resource = 2;
  inline bool has_instance_total_apply_use_resource() const;
  inline void clear_instance_total_apply_use_resource();
  static const int kInstanceTotalApplyUseResourceFieldNumber = 2;
  inline const ::AlProto::ApplyAndUseResourceInfo& instance_total_apply_use_resource() const;
  inline ::AlProto::ApplyAndUseResourceInfo* mutable_instance_total_apply_use_resource();
  inline ::AlProto::ApplyAndUseResourceInfo* release_instance_total_apply_use_resource();
  inline void set_allocated_instance_total_apply_use_resource(::AlProto::ApplyAndUseResourceInfo* instance_total_apply_use_resource);

  // repeated .AlProto.MachineInstanceResourceInfo instance_at_machine_resource = 3;
  inline int instance_at_machine_resource_size() const;
  inline void clear_instance_at_machine_resource();
  static const int kInstanceAtMachineResourceFieldNumber = 3;
  inline const ::AlProto::MachineInstanceResourceInfo& instance_at_machine_resource(int index) const;
  inline ::AlProto::MachineInstanceResourceInfo* mutable_instance_at_machine_resource(int index);
  inline ::AlProto::MachineInstanceResourceInfo* add_instance_at_machine_resource();
  inline const ::google::protobuf::RepeatedPtrField< ::AlProto::MachineInstanceResourceInfo >&
      instance_at_machine_resource() const;
  inline ::google::protobuf::RepeatedPtrField< ::AlProto::MachineInstanceResourceInfo >*
      mutable_instance_at_machine_resource();

  // @@protoc_insertion_point(class_scope:AlProto.AllFrameworkResourceInfo)
 private:
  inline void set_has_framework_instance_id();
  inline void clear_has_framework_instance_id();
  inline void set_has_instance_total_apply_use_resource();
  inline void clear_has_instance_total_apply_use_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AlProto::ApplyAndUseResourceInfo* instance_total_apply_use_resource_;
  ::google::protobuf::RepeatedPtrField< ::AlProto::MachineInstanceResourceInfo > instance_at_machine_resource_;
  ::google::protobuf::uint32 framework_instance_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static AllFrameworkResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class AllMachineResourceInfo : public ::google::protobuf::Message {
 public:
  AllMachineResourceInfo();
  virtual ~AllMachineResourceInfo();

  AllMachineResourceInfo(const AllMachineResourceInfo& from);

  inline AllMachineResourceInfo& operator=(const AllMachineResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllMachineResourceInfo& default_instance();

  void Swap(AllMachineResourceInfo* other);

  // implements Message ----------------------------------------------

  AllMachineResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllMachineResourceInfo& from);
  void MergeFrom(const AllMachineResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nc_ip = 1;
  inline bool has_nc_ip() const;
  inline void clear_nc_ip();
  static const int kNcIpFieldNumber = 1;
  inline const ::std::string& nc_ip() const;
  inline void set_nc_ip(const ::std::string& value);
  inline void set_nc_ip(const char* value);
  inline void set_nc_ip(const char* value, size_t size);
  inline ::std::string* mutable_nc_ip();
  inline ::std::string* release_nc_ip();
  inline void set_allocated_nc_ip(::std::string* nc_ip);

  // repeated .AlProto.InstanceMachineResourceInfo machine_has_instance_resource = 2;
  inline int machine_has_instance_resource_size() const;
  inline void clear_machine_has_instance_resource();
  static const int kMachineHasInstanceResourceFieldNumber = 2;
  inline const ::AlProto::InstanceMachineResourceInfo& machine_has_instance_resource(int index) const;
  inline ::AlProto::InstanceMachineResourceInfo* mutable_machine_has_instance_resource(int index);
  inline ::AlProto::InstanceMachineResourceInfo* add_machine_has_instance_resource();
  inline const ::google::protobuf::RepeatedPtrField< ::AlProto::InstanceMachineResourceInfo >&
      machine_has_instance_resource() const;
  inline ::google::protobuf::RepeatedPtrField< ::AlProto::InstanceMachineResourceInfo >*
      mutable_machine_has_instance_resource();

  // @@protoc_insertion_point(class_scope:AlProto.AllMachineResourceInfo)
 private:
  inline void set_has_nc_ip();
  inline void clear_has_nc_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nc_ip_;
  ::google::protobuf::RepeatedPtrField< ::AlProto::InstanceMachineResourceInfo > machine_has_instance_resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static AllMachineResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInstanceResourceInfo : public ::google::protobuf::Message {
 public:
  FrameworkInstanceResourceInfo();
  virtual ~FrameworkInstanceResourceInfo();

  FrameworkInstanceResourceInfo(const FrameworkInstanceResourceInfo& from);

  inline FrameworkInstanceResourceInfo& operator=(const FrameworkInstanceResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInstanceResourceInfo& default_instance();

  void Swap(FrameworkInstanceResourceInfo* other);

  // implements Message ----------------------------------------------

  FrameworkInstanceResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInstanceResourceInfo& from);
  void MergeFrom(const FrameworkInstanceResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AlProto.AllFrameworkResourceInfo all_framework_resource_info = 1;
  inline int all_framework_resource_info_size() const;
  inline void clear_all_framework_resource_info();
  static const int kAllFrameworkResourceInfoFieldNumber = 1;
  inline const ::AlProto::AllFrameworkResourceInfo& all_framework_resource_info(int index) const;
  inline ::AlProto::AllFrameworkResourceInfo* mutable_all_framework_resource_info(int index);
  inline ::AlProto::AllFrameworkResourceInfo* add_all_framework_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::AlProto::AllFrameworkResourceInfo >&
      all_framework_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::AlProto::AllFrameworkResourceInfo >*
      mutable_all_framework_resource_info();

  // repeated .AlProto.AllMachineResourceInfo all_machine_resource_info = 2;
  inline int all_machine_resource_info_size() const;
  inline void clear_all_machine_resource_info();
  static const int kAllMachineResourceInfoFieldNumber = 2;
  inline const ::AlProto::AllMachineResourceInfo& all_machine_resource_info(int index) const;
  inline ::AlProto::AllMachineResourceInfo* mutable_all_machine_resource_info(int index);
  inline ::AlProto::AllMachineResourceInfo* add_all_machine_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::AlProto::AllMachineResourceInfo >&
      all_machine_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::AlProto::AllMachineResourceInfo >*
      mutable_all_machine_resource_info();

  // @@protoc_insertion_point(class_scope:AlProto.FrameworkInstanceResourceInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AlProto::AllFrameworkResourceInfo > all_framework_resource_info_;
  ::google::protobuf::RepeatedPtrField< ::AlProto::AllMachineResourceInfo > all_machine_resource_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static FrameworkInstanceResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetBusinessEntry : public ::google::protobuf::Message {
 public:
  GetBusinessEntry();
  virtual ~GetBusinessEntry();

  GetBusinessEntry(const GetBusinessEntry& from);

  inline GetBusinessEntry& operator=(const GetBusinessEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBusinessEntry& default_instance();

  void Swap(GetBusinessEntry* other);

  // implements Message ----------------------------------------------

  GetBusinessEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBusinessEntry& from);
  void MergeFrom(const GetBusinessEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 framework_instance_id = 1;
  inline bool has_framework_instance_id() const;
  inline void clear_framework_instance_id();
  static const int kFrameworkInstanceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_instance_id() const;
  inline void set_framework_instance_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AlProto.GetBusinessEntry)
 private:
  inline void set_has_framework_instance_id();
  inline void clear_has_framework_instance_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 framework_instance_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetBusinessEntry* default_instance_;
};
// -------------------------------------------------------------------

class GetBusinessEntryAck : public ::google::protobuf::Message {
 public:
  GetBusinessEntryAck();
  virtual ~GetBusinessEntryAck();

  GetBusinessEntryAck(const GetBusinessEntryAck& from);

  inline GetBusinessEntryAck& operator=(const GetBusinessEntryAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBusinessEntryAck& default_instance();

  void Swap(GetBusinessEntryAck* other);

  // implements Message ----------------------------------------------

  GetBusinessEntryAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBusinessEntryAck& from);
  void MergeFrom(const GetBusinessEntryAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string entry_ip = 1;
  inline bool has_entry_ip() const;
  inline void clear_entry_ip();
  static const int kEntryIpFieldNumber = 1;
  inline const ::std::string& entry_ip() const;
  inline void set_entry_ip(const ::std::string& value);
  inline void set_entry_ip(const char* value);
  inline void set_entry_ip(const char* value, size_t size);
  inline ::std::string* mutable_entry_ip();
  inline ::std::string* release_entry_ip();
  inline void set_allocated_entry_ip(::std::string* entry_ip);

  // required uint32 entry_port = 2;
  inline bool has_entry_port() const;
  inline void clear_entry_port();
  static const int kEntryPortFieldNumber = 2;
  inline ::google::protobuf::uint32 entry_port() const;
  inline void set_entry_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AlProto.GetBusinessEntryAck)
 private:
  inline void set_has_entry_ip();
  inline void clear_has_entry_ip();
  inline void set_has_entry_port();
  inline void clear_has_entry_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* entry_ip_;
  ::google::protobuf::uint32 entry_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AlProtocol_2eproto();
  friend void protobuf_AssignDesc_AlProtocol_2eproto();
  friend void protobuf_ShutdownFile_AlProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetBusinessEntryAck* default_instance_;
};
// ===================================================================


// ===================================================================

// GpuResourceInfo

// required string gpu_name = 1;
inline bool GpuResourceInfo::has_gpu_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuResourceInfo::set_has_gpu_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuResourceInfo::clear_has_gpu_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuResourceInfo::clear_gpu_name() {
  if (gpu_name_ != &::google::protobuf::internal::kEmptyString) {
    gpu_name_->clear();
  }
  clear_has_gpu_name();
}
inline const ::std::string& GpuResourceInfo::gpu_name() const {
  return *gpu_name_;
}
inline void GpuResourceInfo::set_gpu_name(const ::std::string& value) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(value);
}
inline void GpuResourceInfo::set_gpu_name(const char* value) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(value);
}
inline void GpuResourceInfo::set_gpu_name(const char* value, size_t size) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpuResourceInfo::mutable_gpu_name() {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  return gpu_name_;
}
inline ::std::string* GpuResourceInfo::release_gpu_name() {
  clear_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gpu_name_;
    gpu_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GpuResourceInfo::set_allocated_gpu_name(::std::string* gpu_name) {
  if (gpu_name_ != &::google::protobuf::internal::kEmptyString) {
    delete gpu_name_;
  }
  if (gpu_name) {
    set_has_gpu_name();
    gpu_name_ = gpu_name;
  } else {
    clear_has_gpu_name();
    gpu_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gpu_mem_size = 2;
inline bool GpuResourceInfo::has_gpu_mem_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuResourceInfo::set_has_gpu_mem_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuResourceInfo::clear_has_gpu_mem_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuResourceInfo::clear_gpu_mem_size() {
  gpu_mem_size_ = 0u;
  clear_has_gpu_mem_size();
}
inline ::google::protobuf::uint32 GpuResourceInfo::gpu_mem_size() const {
  return gpu_mem_size_;
}
inline void GpuResourceInfo::set_gpu_mem_size(::google::protobuf::uint32 value) {
  set_has_gpu_mem_size();
  gpu_mem_size_ = value;
}

// -------------------------------------------------------------------

// ResourceInfo

// required double cpu_num = 1;
inline bool ResourceInfo::has_cpu_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceInfo::set_has_cpu_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceInfo::clear_has_cpu_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceInfo::clear_cpu_num() {
  cpu_num_ = 0;
  clear_has_cpu_num();
}
inline double ResourceInfo::cpu_num() const {
  return cpu_num_;
}
inline void ResourceInfo::set_cpu_num(double value) {
  set_has_cpu_num();
  cpu_num_ = value;
}

// required uint32 cpu_mem_size = 2;
inline bool ResourceInfo::has_cpu_mem_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceInfo::set_has_cpu_mem_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceInfo::clear_has_cpu_mem_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceInfo::clear_cpu_mem_size() {
  cpu_mem_size_ = 0u;
  clear_has_cpu_mem_size();
}
inline ::google::protobuf::uint32 ResourceInfo::cpu_mem_size() const {
  return cpu_mem_size_;
}
inline void ResourceInfo::set_cpu_mem_size(::google::protobuf::uint32 value) {
  set_has_cpu_mem_size();
  cpu_mem_size_ = value;
}

// optional uint32 gpu_num = 3;
inline bool ResourceInfo::has_gpu_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceInfo::set_has_gpu_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceInfo::clear_has_gpu_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceInfo::clear_gpu_num() {
  gpu_num_ = 0u;
  clear_has_gpu_num();
}
inline ::google::protobuf::uint32 ResourceInfo::gpu_num() const {
  return gpu_num_;
}
inline void ResourceInfo::set_gpu_num(::google::protobuf::uint32 value) {
  set_has_gpu_num();
  gpu_num_ = value;
}

// repeated .AlProto.GpuResourceInfo gpu_resource_info = 4;
inline int ResourceInfo::gpu_resource_info_size() const {
  return gpu_resource_info_.size();
}
inline void ResourceInfo::clear_gpu_resource_info() {
  gpu_resource_info_.Clear();
}
inline const ::AlProto::GpuResourceInfo& ResourceInfo::gpu_resource_info(int index) const {
  return gpu_resource_info_.Get(index);
}
inline ::AlProto::GpuResourceInfo* ResourceInfo::mutable_gpu_resource_info(int index) {
  return gpu_resource_info_.Mutable(index);
}
inline ::AlProto::GpuResourceInfo* ResourceInfo::add_gpu_resource_info() {
  return gpu_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AlProto::GpuResourceInfo >&
ResourceInfo::gpu_resource_info() const {
  return gpu_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::AlProto::GpuResourceInfo >*
ResourceInfo::mutable_gpu_resource_info() {
  return &gpu_resource_info_;
}

// -------------------------------------------------------------------

// FrameworkIDInfo

// required uint32 framework_id = 1;
inline bool FrameworkIDInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkIDInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkIDInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkIDInfo::clear_framework_id() {
  framework_id_ = 0u;
  clear_has_framework_id();
}
inline ::google::protobuf::uint32 FrameworkIDInfo::framework_id() const {
  return framework_id_;
}
inline void FrameworkIDInfo::set_framework_id(::google::protobuf::uint32 value) {
  set_has_framework_id();
  framework_id_ = value;
}

// -------------------------------------------------------------------

// FrameworkInstanceInfo

// required uint32 framework_id = 1;
inline bool FrameworkInstanceInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInstanceInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInstanceInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInstanceInfo::clear_framework_id() {
  framework_id_ = 0u;
  clear_has_framework_id();
}
inline ::google::protobuf::uint32 FrameworkInstanceInfo::framework_id() const {
  return framework_id_;
}
inline void FrameworkInstanceInfo::set_framework_id(::google::protobuf::uint32 value) {
  set_has_framework_id();
  framework_id_ = value;
}

// required uint32 framework_instance_id = 2;
inline bool FrameworkInstanceInfo::has_framework_instance_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkInstanceInfo::set_has_framework_instance_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkInstanceInfo::clear_has_framework_instance_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkInstanceInfo::clear_framework_instance_id() {
  framework_instance_id_ = 0u;
  clear_has_framework_instance_id();
}
inline ::google::protobuf::uint32 FrameworkInstanceInfo::framework_instance_id() const {
  return framework_instance_id_;
}
inline void FrameworkInstanceInfo::set_framework_instance_id(::google::protobuf::uint32 value) {
  set_has_framework_instance_id();
  framework_instance_id_ = value;
}

// -------------------------------------------------------------------

// StartRootModule

// required uint32 framework_id = 1;
inline bool StartRootModule::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartRootModule::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartRootModule::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartRootModule::clear_framework_id() {
  framework_id_ = 0u;
  clear_has_framework_id();
}
inline ::google::protobuf::uint32 StartRootModule::framework_id() const {
  return framework_id_;
}
inline void StartRootModule::set_framework_id(::google::protobuf::uint32 value) {
  set_has_framework_id();
  framework_id_ = value;
}

// optional string image_lable = 2;
inline bool StartRootModule::has_image_lable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartRootModule::set_has_image_lable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartRootModule::clear_has_image_lable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartRootModule::clear_image_lable() {
  if (image_lable_ != &::google::protobuf::internal::kEmptyString) {
    image_lable_->clear();
  }
  clear_has_image_lable();
}
inline const ::std::string& StartRootModule::image_lable() const {
  return *image_lable_;
}
inline void StartRootModule::set_image_lable(const ::std::string& value) {
  set_has_image_lable();
  if (image_lable_ == &::google::protobuf::internal::kEmptyString) {
    image_lable_ = new ::std::string;
  }
  image_lable_->assign(value);
}
inline void StartRootModule::set_image_lable(const char* value) {
  set_has_image_lable();
  if (image_lable_ == &::google::protobuf::internal::kEmptyString) {
    image_lable_ = new ::std::string;
  }
  image_lable_->assign(value);
}
inline void StartRootModule::set_image_lable(const char* value, size_t size) {
  set_has_image_lable();
  if (image_lable_ == &::google::protobuf::internal::kEmptyString) {
    image_lable_ = new ::std::string;
  }
  image_lable_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartRootModule::mutable_image_lable() {
  set_has_image_lable();
  if (image_lable_ == &::google::protobuf::internal::kEmptyString) {
    image_lable_ = new ::std::string;
  }
  return image_lable_;
}
inline ::std::string* StartRootModule::release_image_lable() {
  clear_has_image_lable();
  if (image_lable_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_lable_;
    image_lable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StartRootModule::set_allocated_image_lable(::std::string* image_lable) {
  if (image_lable_ != &::google::protobuf::internal::kEmptyString) {
    delete image_lable_;
  }
  if (image_lable) {
    set_has_image_lable();
    image_lable_ = image_lable;
  } else {
    clear_has_image_lable();
    image_lable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string module_name = 3;
inline bool StartRootModule::has_module_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartRootModule::set_has_module_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartRootModule::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartRootModule::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& StartRootModule::module_name() const {
  return *module_name_;
}
inline void StartRootModule::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void StartRootModule::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void StartRootModule::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartRootModule::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  return module_name_;
}
inline ::std::string* StartRootModule::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StartRootModule::set_allocated_module_name(::std::string* module_name) {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    delete module_name_;
  }
  if (module_name) {
    set_has_module_name();
    module_name_ = module_name;
  } else {
    clear_has_module_name();
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location_file_path = 4;
inline bool StartRootModule::has_location_file_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartRootModule::set_has_location_file_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartRootModule::clear_has_location_file_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartRootModule::clear_location_file_path() {
  if (location_file_path_ != &::google::protobuf::internal::kEmptyString) {
    location_file_path_->clear();
  }
  clear_has_location_file_path();
}
inline const ::std::string& StartRootModule::location_file_path() const {
  return *location_file_path_;
}
inline void StartRootModule::set_location_file_path(const ::std::string& value) {
  set_has_location_file_path();
  if (location_file_path_ == &::google::protobuf::internal::kEmptyString) {
    location_file_path_ = new ::std::string;
  }
  location_file_path_->assign(value);
}
inline void StartRootModule::set_location_file_path(const char* value) {
  set_has_location_file_path();
  if (location_file_path_ == &::google::protobuf::internal::kEmptyString) {
    location_file_path_ = new ::std::string;
  }
  location_file_path_->assign(value);
}
inline void StartRootModule::set_location_file_path(const char* value, size_t size) {
  set_has_location_file_path();
  if (location_file_path_ == &::google::protobuf::internal::kEmptyString) {
    location_file_path_ = new ::std::string;
  }
  location_file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartRootModule::mutable_location_file_path() {
  set_has_location_file_path();
  if (location_file_path_ == &::google::protobuf::internal::kEmptyString) {
    location_file_path_ = new ::std::string;
  }
  return location_file_path_;
}
inline ::std::string* StartRootModule::release_location_file_path() {
  clear_has_location_file_path();
  if (location_file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_file_path_;
    location_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StartRootModule::set_allocated_location_file_path(::std::string* location_file_path) {
  if (location_file_path_ != &::google::protobuf::internal::kEmptyString) {
    delete location_file_path_;
  }
  if (location_file_path) {
    set_has_location_file_path();
    location_file_path_ = location_file_path;
  } else {
    clear_has_location_file_path();
    location_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string nc_ip = 5;
inline bool StartRootModule::has_nc_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartRootModule::set_has_nc_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartRootModule::clear_has_nc_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartRootModule::clear_nc_ip() {
  if (nc_ip_ != &::google::protobuf::internal::kEmptyString) {
    nc_ip_->clear();
  }
  clear_has_nc_ip();
}
inline const ::std::string& StartRootModule::nc_ip() const {
  return *nc_ip_;
}
inline void StartRootModule::set_nc_ip(const ::std::string& value) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(value);
}
inline void StartRootModule::set_nc_ip(const char* value) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(value);
}
inline void StartRootModule::set_nc_ip(const char* value, size_t size) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartRootModule::mutable_nc_ip() {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  return nc_ip_;
}
inline ::std::string* StartRootModule::release_nc_ip() {
  clear_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nc_ip_;
    nc_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StartRootModule::set_allocated_nc_ip(::std::string* nc_ip) {
  if (nc_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete nc_ip_;
  }
  if (nc_ip) {
    set_has_nc_ip();
    nc_ip_ = nc_ip;
  } else {
    clear_has_nc_ip();
    nc_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .AlProto.ResourceInfo request_resource_size = 6;
inline bool StartRootModule::has_request_resource_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StartRootModule::set_has_request_resource_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StartRootModule::clear_has_request_resource_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StartRootModule::clear_request_resource_size() {
  if (request_resource_size_ != NULL) request_resource_size_->::AlProto::ResourceInfo::Clear();
  clear_has_request_resource_size();
}
inline const ::AlProto::ResourceInfo& StartRootModule::request_resource_size() const {
  return request_resource_size_ != NULL ? *request_resource_size_ : *default_instance_->request_resource_size_;
}
inline ::AlProto::ResourceInfo* StartRootModule::mutable_request_resource_size() {
  set_has_request_resource_size();
  if (request_resource_size_ == NULL) request_resource_size_ = new ::AlProto::ResourceInfo;
  return request_resource_size_;
}
inline ::AlProto::ResourceInfo* StartRootModule::release_request_resource_size() {
  clear_has_request_resource_size();
  ::AlProto::ResourceInfo* temp = request_resource_size_;
  request_resource_size_ = NULL;
  return temp;
}
inline void StartRootModule::set_allocated_request_resource_size(::AlProto::ResourceInfo* request_resource_size) {
  delete request_resource_size_;
  request_resource_size_ = request_resource_size;
  if (request_resource_size) {
    set_has_request_resource_size();
  } else {
    clear_has_request_resource_size();
  }
}

// optional uint32 listen_num = 7;
inline bool StartRootModule::has_listen_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StartRootModule::set_has_listen_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StartRootModule::clear_has_listen_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StartRootModule::clear_listen_num() {
  listen_num_ = 0u;
  clear_has_listen_num();
}
inline ::google::protobuf::uint32 StartRootModule::listen_num() const {
  return listen_num_;
}
inline void StartRootModule::set_listen_num(::google::protobuf::uint32 value) {
  set_has_listen_num();
  listen_num_ = value;
}

// optional .AlProto.ResourceInfo framework_max_request_resource_size = 8;
inline bool StartRootModule::has_framework_max_request_resource_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StartRootModule::set_has_framework_max_request_resource_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StartRootModule::clear_has_framework_max_request_resource_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StartRootModule::clear_framework_max_request_resource_size() {
  if (framework_max_request_resource_size_ != NULL) framework_max_request_resource_size_->::AlProto::ResourceInfo::Clear();
  clear_has_framework_max_request_resource_size();
}
inline const ::AlProto::ResourceInfo& StartRootModule::framework_max_request_resource_size() const {
  return framework_max_request_resource_size_ != NULL ? *framework_max_request_resource_size_ : *default_instance_->framework_max_request_resource_size_;
}
inline ::AlProto::ResourceInfo* StartRootModule::mutable_framework_max_request_resource_size() {
  set_has_framework_max_request_resource_size();
  if (framework_max_request_resource_size_ == NULL) framework_max_request_resource_size_ = new ::AlProto::ResourceInfo;
  return framework_max_request_resource_size_;
}
inline ::AlProto::ResourceInfo* StartRootModule::release_framework_max_request_resource_size() {
  clear_has_framework_max_request_resource_size();
  ::AlProto::ResourceInfo* temp = framework_max_request_resource_size_;
  framework_max_request_resource_size_ = NULL;
  return temp;
}
inline void StartRootModule::set_allocated_framework_max_request_resource_size(::AlProto::ResourceInfo* framework_max_request_resource_size) {
  delete framework_max_request_resource_size_;
  framework_max_request_resource_size_ = framework_max_request_resource_size;
  if (framework_max_request_resource_size) {
    set_has_framework_max_request_resource_size();
  } else {
    clear_has_framework_max_request_resource_size();
  }
}

// -------------------------------------------------------------------

// AssignResourceInfo

// required .AlProto.ResourceInfo total_have_resource = 1;
inline bool AssignResourceInfo::has_total_have_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssignResourceInfo::set_has_total_have_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssignResourceInfo::clear_has_total_have_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssignResourceInfo::clear_total_have_resource() {
  if (total_have_resource_ != NULL) total_have_resource_->::AlProto::ResourceInfo::Clear();
  clear_has_total_have_resource();
}
inline const ::AlProto::ResourceInfo& AssignResourceInfo::total_have_resource() const {
  return total_have_resource_ != NULL ? *total_have_resource_ : *default_instance_->total_have_resource_;
}
inline ::AlProto::ResourceInfo* AssignResourceInfo::mutable_total_have_resource() {
  set_has_total_have_resource();
  if (total_have_resource_ == NULL) total_have_resource_ = new ::AlProto::ResourceInfo;
  return total_have_resource_;
}
inline ::AlProto::ResourceInfo* AssignResourceInfo::release_total_have_resource() {
  clear_has_total_have_resource();
  ::AlProto::ResourceInfo* temp = total_have_resource_;
  total_have_resource_ = NULL;
  return temp;
}
inline void AssignResourceInfo::set_allocated_total_have_resource(::AlProto::ResourceInfo* total_have_resource) {
  delete total_have_resource_;
  total_have_resource_ = total_have_resource;
  if (total_have_resource) {
    set_has_total_have_resource();
  } else {
    clear_has_total_have_resource();
  }
}

// optional .AlProto.ResourceInfo total_not_assign_resource = 2;
inline bool AssignResourceInfo::has_total_not_assign_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssignResourceInfo::set_has_total_not_assign_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssignResourceInfo::clear_has_total_not_assign_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssignResourceInfo::clear_total_not_assign_resource() {
  if (total_not_assign_resource_ != NULL) total_not_assign_resource_->::AlProto::ResourceInfo::Clear();
  clear_has_total_not_assign_resource();
}
inline const ::AlProto::ResourceInfo& AssignResourceInfo::total_not_assign_resource() const {
  return total_not_assign_resource_ != NULL ? *total_not_assign_resource_ : *default_instance_->total_not_assign_resource_;
}
inline ::AlProto::ResourceInfo* AssignResourceInfo::mutable_total_not_assign_resource() {
  set_has_total_not_assign_resource();
  if (total_not_assign_resource_ == NULL) total_not_assign_resource_ = new ::AlProto::ResourceInfo;
  return total_not_assign_resource_;
}
inline ::AlProto::ResourceInfo* AssignResourceInfo::release_total_not_assign_resource() {
  clear_has_total_not_assign_resource();
  ::AlProto::ResourceInfo* temp = total_not_assign_resource_;
  total_not_assign_resource_ = NULL;
  return temp;
}
inline void AssignResourceInfo::set_allocated_total_not_assign_resource(::AlProto::ResourceInfo* total_not_assign_resource) {
  delete total_not_assign_resource_;
  total_not_assign_resource_ = total_not_assign_resource;
  if (total_not_assign_resource) {
    set_has_total_not_assign_resource();
  } else {
    clear_has_total_not_assign_resource();
  }
}

// optional .AlProto.ResourceInfo total_already_assign_resource = 3;
inline bool AssignResourceInfo::has_total_already_assign_resource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AssignResourceInfo::set_has_total_already_assign_resource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AssignResourceInfo::clear_has_total_already_assign_resource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AssignResourceInfo::clear_total_already_assign_resource() {
  if (total_already_assign_resource_ != NULL) total_already_assign_resource_->::AlProto::ResourceInfo::Clear();
  clear_has_total_already_assign_resource();
}
inline const ::AlProto::ResourceInfo& AssignResourceInfo::total_already_assign_resource() const {
  return total_already_assign_resource_ != NULL ? *total_already_assign_resource_ : *default_instance_->total_already_assign_resource_;
}
inline ::AlProto::ResourceInfo* AssignResourceInfo::mutable_total_already_assign_resource() {
  set_has_total_already_assign_resource();
  if (total_already_assign_resource_ == NULL) total_already_assign_resource_ = new ::AlProto::ResourceInfo;
  return total_already_assign_resource_;
}
inline ::AlProto::ResourceInfo* AssignResourceInfo::release_total_already_assign_resource() {
  clear_has_total_already_assign_resource();
  ::AlProto::ResourceInfo* temp = total_already_assign_resource_;
  total_already_assign_resource_ = NULL;
  return temp;
}
inline void AssignResourceInfo::set_allocated_total_already_assign_resource(::AlProto::ResourceInfo* total_already_assign_resource) {
  delete total_already_assign_resource_;
  total_already_assign_resource_ = total_already_assign_resource;
  if (total_already_assign_resource) {
    set_has_total_already_assign_resource();
  } else {
    clear_has_total_already_assign_resource();
  }
}

// -------------------------------------------------------------------

// ActualResourceInfo

// required .AlProto.ResourceInfo total_use_resource = 1;
inline bool ActualResourceInfo::has_total_use_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActualResourceInfo::set_has_total_use_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActualResourceInfo::clear_has_total_use_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActualResourceInfo::clear_total_use_resource() {
  if (total_use_resource_ != NULL) total_use_resource_->::AlProto::ResourceInfo::Clear();
  clear_has_total_use_resource();
}
inline const ::AlProto::ResourceInfo& ActualResourceInfo::total_use_resource() const {
  return total_use_resource_ != NULL ? *total_use_resource_ : *default_instance_->total_use_resource_;
}
inline ::AlProto::ResourceInfo* ActualResourceInfo::mutable_total_use_resource() {
  set_has_total_use_resource();
  if (total_use_resource_ == NULL) total_use_resource_ = new ::AlProto::ResourceInfo;
  return total_use_resource_;
}
inline ::AlProto::ResourceInfo* ActualResourceInfo::release_total_use_resource() {
  clear_has_total_use_resource();
  ::AlProto::ResourceInfo* temp = total_use_resource_;
  total_use_resource_ = NULL;
  return temp;
}
inline void ActualResourceInfo::set_allocated_total_use_resource(::AlProto::ResourceInfo* total_use_resource) {
  delete total_use_resource_;
  total_use_resource_ = total_use_resource;
  if (total_use_resource) {
    set_has_total_use_resource();
  } else {
    clear_has_total_use_resource();
  }
}

// optional .AlProto.ResourceInfo total_not_use_resource = 2;
inline bool ActualResourceInfo::has_total_not_use_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActualResourceInfo::set_has_total_not_use_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActualResourceInfo::clear_has_total_not_use_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActualResourceInfo::clear_total_not_use_resource() {
  if (total_not_use_resource_ != NULL) total_not_use_resource_->::AlProto::ResourceInfo::Clear();
  clear_has_total_not_use_resource();
}
inline const ::AlProto::ResourceInfo& ActualResourceInfo::total_not_use_resource() const {
  return total_not_use_resource_ != NULL ? *total_not_use_resource_ : *default_instance_->total_not_use_resource_;
}
inline ::AlProto::ResourceInfo* ActualResourceInfo::mutable_total_not_use_resource() {
  set_has_total_not_use_resource();
  if (total_not_use_resource_ == NULL) total_not_use_resource_ = new ::AlProto::ResourceInfo;
  return total_not_use_resource_;
}
inline ::AlProto::ResourceInfo* ActualResourceInfo::release_total_not_use_resource() {
  clear_has_total_not_use_resource();
  ::AlProto::ResourceInfo* temp = total_not_use_resource_;
  total_not_use_resource_ = NULL;
  return temp;
}
inline void ActualResourceInfo::set_allocated_total_not_use_resource(::AlProto::ResourceInfo* total_not_use_resource) {
  delete total_not_use_resource_;
  total_not_use_resource_ = total_not_use_resource;
  if (total_not_use_resource) {
    set_has_total_not_use_resource();
  } else {
    clear_has_total_not_use_resource();
  }
}

// -------------------------------------------------------------------

// AssignAndActualResourceInfo

// required .AlProto.AssignResourceInfo assign_resource = 1;
inline bool AssignAndActualResourceInfo::has_assign_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssignAndActualResourceInfo::set_has_assign_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssignAndActualResourceInfo::clear_has_assign_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssignAndActualResourceInfo::clear_assign_resource() {
  if (assign_resource_ != NULL) assign_resource_->::AlProto::AssignResourceInfo::Clear();
  clear_has_assign_resource();
}
inline const ::AlProto::AssignResourceInfo& AssignAndActualResourceInfo::assign_resource() const {
  return assign_resource_ != NULL ? *assign_resource_ : *default_instance_->assign_resource_;
}
inline ::AlProto::AssignResourceInfo* AssignAndActualResourceInfo::mutable_assign_resource() {
  set_has_assign_resource();
  if (assign_resource_ == NULL) assign_resource_ = new ::AlProto::AssignResourceInfo;
  return assign_resource_;
}
inline ::AlProto::AssignResourceInfo* AssignAndActualResourceInfo::release_assign_resource() {
  clear_has_assign_resource();
  ::AlProto::AssignResourceInfo* temp = assign_resource_;
  assign_resource_ = NULL;
  return temp;
}
inline void AssignAndActualResourceInfo::set_allocated_assign_resource(::AlProto::AssignResourceInfo* assign_resource) {
  delete assign_resource_;
  assign_resource_ = assign_resource;
  if (assign_resource) {
    set_has_assign_resource();
  } else {
    clear_has_assign_resource();
  }
}

// optional .AlProto.ActualResourceInfo actual_resource = 2;
inline bool AssignAndActualResourceInfo::has_actual_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssignAndActualResourceInfo::set_has_actual_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssignAndActualResourceInfo::clear_has_actual_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssignAndActualResourceInfo::clear_actual_resource() {
  if (actual_resource_ != NULL) actual_resource_->::AlProto::ActualResourceInfo::Clear();
  clear_has_actual_resource();
}
inline const ::AlProto::ActualResourceInfo& AssignAndActualResourceInfo::actual_resource() const {
  return actual_resource_ != NULL ? *actual_resource_ : *default_instance_->actual_resource_;
}
inline ::AlProto::ActualResourceInfo* AssignAndActualResourceInfo::mutable_actual_resource() {
  set_has_actual_resource();
  if (actual_resource_ == NULL) actual_resource_ = new ::AlProto::ActualResourceInfo;
  return actual_resource_;
}
inline ::AlProto::ActualResourceInfo* AssignAndActualResourceInfo::release_actual_resource() {
  clear_has_actual_resource();
  ::AlProto::ActualResourceInfo* temp = actual_resource_;
  actual_resource_ = NULL;
  return temp;
}
inline void AssignAndActualResourceInfo::set_allocated_actual_resource(::AlProto::ActualResourceInfo* actual_resource) {
  delete actual_resource_;
  actual_resource_ = actual_resource;
  if (actual_resource) {
    set_has_actual_resource();
  } else {
    clear_has_actual_resource();
  }
}

// -------------------------------------------------------------------

// PlatformAndMachineResouceInfo

// required .AlProto.AssignAndActualResourceInfo platform_resource = 1;
inline bool PlatformAndMachineResouceInfo::has_platform_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlatformAndMachineResouceInfo::set_has_platform_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlatformAndMachineResouceInfo::clear_has_platform_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlatformAndMachineResouceInfo::clear_platform_resource() {
  if (platform_resource_ != NULL) platform_resource_->::AlProto::AssignAndActualResourceInfo::Clear();
  clear_has_platform_resource();
}
inline const ::AlProto::AssignAndActualResourceInfo& PlatformAndMachineResouceInfo::platform_resource() const {
  return platform_resource_ != NULL ? *platform_resource_ : *default_instance_->platform_resource_;
}
inline ::AlProto::AssignAndActualResourceInfo* PlatformAndMachineResouceInfo::mutable_platform_resource() {
  set_has_platform_resource();
  if (platform_resource_ == NULL) platform_resource_ = new ::AlProto::AssignAndActualResourceInfo;
  return platform_resource_;
}
inline ::AlProto::AssignAndActualResourceInfo* PlatformAndMachineResouceInfo::release_platform_resource() {
  clear_has_platform_resource();
  ::AlProto::AssignAndActualResourceInfo* temp = platform_resource_;
  platform_resource_ = NULL;
  return temp;
}
inline void PlatformAndMachineResouceInfo::set_allocated_platform_resource(::AlProto::AssignAndActualResourceInfo* platform_resource) {
  delete platform_resource_;
  platform_resource_ = platform_resource;
  if (platform_resource) {
    set_has_platform_resource();
  } else {
    clear_has_platform_resource();
  }
}

// repeated .AlProto.AssignAndActualResourceInfo machine_resource = 2;
inline int PlatformAndMachineResouceInfo::machine_resource_size() const {
  return machine_resource_.size();
}
inline void PlatformAndMachineResouceInfo::clear_machine_resource() {
  machine_resource_.Clear();
}
inline const ::AlProto::AssignAndActualResourceInfo& PlatformAndMachineResouceInfo::machine_resource(int index) const {
  return machine_resource_.Get(index);
}
inline ::AlProto::AssignAndActualResourceInfo* PlatformAndMachineResouceInfo::mutable_machine_resource(int index) {
  return machine_resource_.Mutable(index);
}
inline ::AlProto::AssignAndActualResourceInfo* PlatformAndMachineResouceInfo::add_machine_resource() {
  return machine_resource_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AlProto::AssignAndActualResourceInfo >&
PlatformAndMachineResouceInfo::machine_resource() const {
  return machine_resource_;
}
inline ::google::protobuf::RepeatedPtrField< ::AlProto::AssignAndActualResourceInfo >*
PlatformAndMachineResouceInfo::mutable_machine_resource() {
  return &machine_resource_;
}

// -------------------------------------------------------------------

// ApplyAndUseResourceInfo

// required .AlProto.ResourceInfo apply_resource = 1;
inline bool ApplyAndUseResourceInfo::has_apply_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyAndUseResourceInfo::set_has_apply_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyAndUseResourceInfo::clear_has_apply_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyAndUseResourceInfo::clear_apply_resource() {
  if (apply_resource_ != NULL) apply_resource_->::AlProto::ResourceInfo::Clear();
  clear_has_apply_resource();
}
inline const ::AlProto::ResourceInfo& ApplyAndUseResourceInfo::apply_resource() const {
  return apply_resource_ != NULL ? *apply_resource_ : *default_instance_->apply_resource_;
}
inline ::AlProto::ResourceInfo* ApplyAndUseResourceInfo::mutable_apply_resource() {
  set_has_apply_resource();
  if (apply_resource_ == NULL) apply_resource_ = new ::AlProto::ResourceInfo;
  return apply_resource_;
}
inline ::AlProto::ResourceInfo* ApplyAndUseResourceInfo::release_apply_resource() {
  clear_has_apply_resource();
  ::AlProto::ResourceInfo* temp = apply_resource_;
  apply_resource_ = NULL;
  return temp;
}
inline void ApplyAndUseResourceInfo::set_allocated_apply_resource(::AlProto::ResourceInfo* apply_resource) {
  delete apply_resource_;
  apply_resource_ = apply_resource;
  if (apply_resource) {
    set_has_apply_resource();
  } else {
    clear_has_apply_resource();
  }
}

// optional .AlProto.ResourceInfo use_resource = 2;
inline bool ApplyAndUseResourceInfo::has_use_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyAndUseResourceInfo::set_has_use_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyAndUseResourceInfo::clear_has_use_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyAndUseResourceInfo::clear_use_resource() {
  if (use_resource_ != NULL) use_resource_->::AlProto::ResourceInfo::Clear();
  clear_has_use_resource();
}
inline const ::AlProto::ResourceInfo& ApplyAndUseResourceInfo::use_resource() const {
  return use_resource_ != NULL ? *use_resource_ : *default_instance_->use_resource_;
}
inline ::AlProto::ResourceInfo* ApplyAndUseResourceInfo::mutable_use_resource() {
  set_has_use_resource();
  if (use_resource_ == NULL) use_resource_ = new ::AlProto::ResourceInfo;
  return use_resource_;
}
inline ::AlProto::ResourceInfo* ApplyAndUseResourceInfo::release_use_resource() {
  clear_has_use_resource();
  ::AlProto::ResourceInfo* temp = use_resource_;
  use_resource_ = NULL;
  return temp;
}
inline void ApplyAndUseResourceInfo::set_allocated_use_resource(::AlProto::ResourceInfo* use_resource) {
  delete use_resource_;
  use_resource_ = use_resource;
  if (use_resource) {
    set_has_use_resource();
  } else {
    clear_has_use_resource();
  }
}

// -------------------------------------------------------------------

// MachineInstanceResourceInfo

// required string nc_ip = 1;
inline bool MachineInstanceResourceInfo::has_nc_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MachineInstanceResourceInfo::set_has_nc_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MachineInstanceResourceInfo::clear_has_nc_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MachineInstanceResourceInfo::clear_nc_ip() {
  if (nc_ip_ != &::google::protobuf::internal::kEmptyString) {
    nc_ip_->clear();
  }
  clear_has_nc_ip();
}
inline const ::std::string& MachineInstanceResourceInfo::nc_ip() const {
  return *nc_ip_;
}
inline void MachineInstanceResourceInfo::set_nc_ip(const ::std::string& value) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(value);
}
inline void MachineInstanceResourceInfo::set_nc_ip(const char* value) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(value);
}
inline void MachineInstanceResourceInfo::set_nc_ip(const char* value, size_t size) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MachineInstanceResourceInfo::mutable_nc_ip() {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  return nc_ip_;
}
inline ::std::string* MachineInstanceResourceInfo::release_nc_ip() {
  clear_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nc_ip_;
    nc_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MachineInstanceResourceInfo::set_allocated_nc_ip(::std::string* nc_ip) {
  if (nc_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete nc_ip_;
  }
  if (nc_ip) {
    set_has_nc_ip();
    nc_ip_ = nc_ip;
  } else {
    clear_has_nc_ip();
    nc_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .AlProto.ApplyAndUseResourceInfo machine_apply_use_resource = 2;
inline bool MachineInstanceResourceInfo::has_machine_apply_use_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MachineInstanceResourceInfo::set_has_machine_apply_use_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MachineInstanceResourceInfo::clear_has_machine_apply_use_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MachineInstanceResourceInfo::clear_machine_apply_use_resource() {
  if (machine_apply_use_resource_ != NULL) machine_apply_use_resource_->::AlProto::ApplyAndUseResourceInfo::Clear();
  clear_has_machine_apply_use_resource();
}
inline const ::AlProto::ApplyAndUseResourceInfo& MachineInstanceResourceInfo::machine_apply_use_resource() const {
  return machine_apply_use_resource_ != NULL ? *machine_apply_use_resource_ : *default_instance_->machine_apply_use_resource_;
}
inline ::AlProto::ApplyAndUseResourceInfo* MachineInstanceResourceInfo::mutable_machine_apply_use_resource() {
  set_has_machine_apply_use_resource();
  if (machine_apply_use_resource_ == NULL) machine_apply_use_resource_ = new ::AlProto::ApplyAndUseResourceInfo;
  return machine_apply_use_resource_;
}
inline ::AlProto::ApplyAndUseResourceInfo* MachineInstanceResourceInfo::release_machine_apply_use_resource() {
  clear_has_machine_apply_use_resource();
  ::AlProto::ApplyAndUseResourceInfo* temp = machine_apply_use_resource_;
  machine_apply_use_resource_ = NULL;
  return temp;
}
inline void MachineInstanceResourceInfo::set_allocated_machine_apply_use_resource(::AlProto::ApplyAndUseResourceInfo* machine_apply_use_resource) {
  delete machine_apply_use_resource_;
  machine_apply_use_resource_ = machine_apply_use_resource;
  if (machine_apply_use_resource) {
    set_has_machine_apply_use_resource();
  } else {
    clear_has_machine_apply_use_resource();
  }
}

// -------------------------------------------------------------------

// InstanceMachineResourceInfo

// required uint32 framework_instance_id = 1;
inline bool InstanceMachineResourceInfo::has_framework_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceMachineResourceInfo::set_has_framework_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceMachineResourceInfo::clear_has_framework_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceMachineResourceInfo::clear_framework_instance_id() {
  framework_instance_id_ = 0u;
  clear_has_framework_instance_id();
}
inline ::google::protobuf::uint32 InstanceMachineResourceInfo::framework_instance_id() const {
  return framework_instance_id_;
}
inline void InstanceMachineResourceInfo::set_framework_instance_id(::google::protobuf::uint32 value) {
  set_has_framework_instance_id();
  framework_instance_id_ = value;
}

// optional .AlProto.ApplyAndUseResourceInfo instance_apply_use_resource = 2;
inline bool InstanceMachineResourceInfo::has_instance_apply_use_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceMachineResourceInfo::set_has_instance_apply_use_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceMachineResourceInfo::clear_has_instance_apply_use_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceMachineResourceInfo::clear_instance_apply_use_resource() {
  if (instance_apply_use_resource_ != NULL) instance_apply_use_resource_->::AlProto::ApplyAndUseResourceInfo::Clear();
  clear_has_instance_apply_use_resource();
}
inline const ::AlProto::ApplyAndUseResourceInfo& InstanceMachineResourceInfo::instance_apply_use_resource() const {
  return instance_apply_use_resource_ != NULL ? *instance_apply_use_resource_ : *default_instance_->instance_apply_use_resource_;
}
inline ::AlProto::ApplyAndUseResourceInfo* InstanceMachineResourceInfo::mutable_instance_apply_use_resource() {
  set_has_instance_apply_use_resource();
  if (instance_apply_use_resource_ == NULL) instance_apply_use_resource_ = new ::AlProto::ApplyAndUseResourceInfo;
  return instance_apply_use_resource_;
}
inline ::AlProto::ApplyAndUseResourceInfo* InstanceMachineResourceInfo::release_instance_apply_use_resource() {
  clear_has_instance_apply_use_resource();
  ::AlProto::ApplyAndUseResourceInfo* temp = instance_apply_use_resource_;
  instance_apply_use_resource_ = NULL;
  return temp;
}
inline void InstanceMachineResourceInfo::set_allocated_instance_apply_use_resource(::AlProto::ApplyAndUseResourceInfo* instance_apply_use_resource) {
  delete instance_apply_use_resource_;
  instance_apply_use_resource_ = instance_apply_use_resource;
  if (instance_apply_use_resource) {
    set_has_instance_apply_use_resource();
  } else {
    clear_has_instance_apply_use_resource();
  }
}

// -------------------------------------------------------------------

// AllFrameworkResourceInfo

// required uint32 framework_instance_id = 1;
inline bool AllFrameworkResourceInfo::has_framework_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllFrameworkResourceInfo::set_has_framework_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllFrameworkResourceInfo::clear_has_framework_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllFrameworkResourceInfo::clear_framework_instance_id() {
  framework_instance_id_ = 0u;
  clear_has_framework_instance_id();
}
inline ::google::protobuf::uint32 AllFrameworkResourceInfo::framework_instance_id() const {
  return framework_instance_id_;
}
inline void AllFrameworkResourceInfo::set_framework_instance_id(::google::protobuf::uint32 value) {
  set_has_framework_instance_id();
  framework_instance_id_ = value;
}

// optional .AlProto.ApplyAndUseResourceInfo instance_total_apply_use_resource = 2;
inline bool AllFrameworkResourceInfo::has_instance_total_apply_use_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllFrameworkResourceInfo::set_has_instance_total_apply_use_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllFrameworkResourceInfo::clear_has_instance_total_apply_use_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllFrameworkResourceInfo::clear_instance_total_apply_use_resource() {
  if (instance_total_apply_use_resource_ != NULL) instance_total_apply_use_resource_->::AlProto::ApplyAndUseResourceInfo::Clear();
  clear_has_instance_total_apply_use_resource();
}
inline const ::AlProto::ApplyAndUseResourceInfo& AllFrameworkResourceInfo::instance_total_apply_use_resource() const {
  return instance_total_apply_use_resource_ != NULL ? *instance_total_apply_use_resource_ : *default_instance_->instance_total_apply_use_resource_;
}
inline ::AlProto::ApplyAndUseResourceInfo* AllFrameworkResourceInfo::mutable_instance_total_apply_use_resource() {
  set_has_instance_total_apply_use_resource();
  if (instance_total_apply_use_resource_ == NULL) instance_total_apply_use_resource_ = new ::AlProto::ApplyAndUseResourceInfo;
  return instance_total_apply_use_resource_;
}
inline ::AlProto::ApplyAndUseResourceInfo* AllFrameworkResourceInfo::release_instance_total_apply_use_resource() {
  clear_has_instance_total_apply_use_resource();
  ::AlProto::ApplyAndUseResourceInfo* temp = instance_total_apply_use_resource_;
  instance_total_apply_use_resource_ = NULL;
  return temp;
}
inline void AllFrameworkResourceInfo::set_allocated_instance_total_apply_use_resource(::AlProto::ApplyAndUseResourceInfo* instance_total_apply_use_resource) {
  delete instance_total_apply_use_resource_;
  instance_total_apply_use_resource_ = instance_total_apply_use_resource;
  if (instance_total_apply_use_resource) {
    set_has_instance_total_apply_use_resource();
  } else {
    clear_has_instance_total_apply_use_resource();
  }
}

// repeated .AlProto.MachineInstanceResourceInfo instance_at_machine_resource = 3;
inline int AllFrameworkResourceInfo::instance_at_machine_resource_size() const {
  return instance_at_machine_resource_.size();
}
inline void AllFrameworkResourceInfo::clear_instance_at_machine_resource() {
  instance_at_machine_resource_.Clear();
}
inline const ::AlProto::MachineInstanceResourceInfo& AllFrameworkResourceInfo::instance_at_machine_resource(int index) const {
  return instance_at_machine_resource_.Get(index);
}
inline ::AlProto::MachineInstanceResourceInfo* AllFrameworkResourceInfo::mutable_instance_at_machine_resource(int index) {
  return instance_at_machine_resource_.Mutable(index);
}
inline ::AlProto::MachineInstanceResourceInfo* AllFrameworkResourceInfo::add_instance_at_machine_resource() {
  return instance_at_machine_resource_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AlProto::MachineInstanceResourceInfo >&
AllFrameworkResourceInfo::instance_at_machine_resource() const {
  return instance_at_machine_resource_;
}
inline ::google::protobuf::RepeatedPtrField< ::AlProto::MachineInstanceResourceInfo >*
AllFrameworkResourceInfo::mutable_instance_at_machine_resource() {
  return &instance_at_machine_resource_;
}

// -------------------------------------------------------------------

// AllMachineResourceInfo

// required string nc_ip = 1;
inline bool AllMachineResourceInfo::has_nc_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllMachineResourceInfo::set_has_nc_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllMachineResourceInfo::clear_has_nc_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllMachineResourceInfo::clear_nc_ip() {
  if (nc_ip_ != &::google::protobuf::internal::kEmptyString) {
    nc_ip_->clear();
  }
  clear_has_nc_ip();
}
inline const ::std::string& AllMachineResourceInfo::nc_ip() const {
  return *nc_ip_;
}
inline void AllMachineResourceInfo::set_nc_ip(const ::std::string& value) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(value);
}
inline void AllMachineResourceInfo::set_nc_ip(const char* value) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(value);
}
inline void AllMachineResourceInfo::set_nc_ip(const char* value, size_t size) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllMachineResourceInfo::mutable_nc_ip() {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  return nc_ip_;
}
inline ::std::string* AllMachineResourceInfo::release_nc_ip() {
  clear_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nc_ip_;
    nc_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AllMachineResourceInfo::set_allocated_nc_ip(::std::string* nc_ip) {
  if (nc_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete nc_ip_;
  }
  if (nc_ip) {
    set_has_nc_ip();
    nc_ip_ = nc_ip;
  } else {
    clear_has_nc_ip();
    nc_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .AlProto.InstanceMachineResourceInfo machine_has_instance_resource = 2;
inline int AllMachineResourceInfo::machine_has_instance_resource_size() const {
  return machine_has_instance_resource_.size();
}
inline void AllMachineResourceInfo::clear_machine_has_instance_resource() {
  machine_has_instance_resource_.Clear();
}
inline const ::AlProto::InstanceMachineResourceInfo& AllMachineResourceInfo::machine_has_instance_resource(int index) const {
  return machine_has_instance_resource_.Get(index);
}
inline ::AlProto::InstanceMachineResourceInfo* AllMachineResourceInfo::mutable_machine_has_instance_resource(int index) {
  return machine_has_instance_resource_.Mutable(index);
}
inline ::AlProto::InstanceMachineResourceInfo* AllMachineResourceInfo::add_machine_has_instance_resource() {
  return machine_has_instance_resource_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AlProto::InstanceMachineResourceInfo >&
AllMachineResourceInfo::machine_has_instance_resource() const {
  return machine_has_instance_resource_;
}
inline ::google::protobuf::RepeatedPtrField< ::AlProto::InstanceMachineResourceInfo >*
AllMachineResourceInfo::mutable_machine_has_instance_resource() {
  return &machine_has_instance_resource_;
}

// -------------------------------------------------------------------

// FrameworkInstanceResourceInfo

// repeated .AlProto.AllFrameworkResourceInfo all_framework_resource_info = 1;
inline int FrameworkInstanceResourceInfo::all_framework_resource_info_size() const {
  return all_framework_resource_info_.size();
}
inline void FrameworkInstanceResourceInfo::clear_all_framework_resource_info() {
  all_framework_resource_info_.Clear();
}
inline const ::AlProto::AllFrameworkResourceInfo& FrameworkInstanceResourceInfo::all_framework_resource_info(int index) const {
  return all_framework_resource_info_.Get(index);
}
inline ::AlProto::AllFrameworkResourceInfo* FrameworkInstanceResourceInfo::mutable_all_framework_resource_info(int index) {
  return all_framework_resource_info_.Mutable(index);
}
inline ::AlProto::AllFrameworkResourceInfo* FrameworkInstanceResourceInfo::add_all_framework_resource_info() {
  return all_framework_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AlProto::AllFrameworkResourceInfo >&
FrameworkInstanceResourceInfo::all_framework_resource_info() const {
  return all_framework_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::AlProto::AllFrameworkResourceInfo >*
FrameworkInstanceResourceInfo::mutable_all_framework_resource_info() {
  return &all_framework_resource_info_;
}

// repeated .AlProto.AllMachineResourceInfo all_machine_resource_info = 2;
inline int FrameworkInstanceResourceInfo::all_machine_resource_info_size() const {
  return all_machine_resource_info_.size();
}
inline void FrameworkInstanceResourceInfo::clear_all_machine_resource_info() {
  all_machine_resource_info_.Clear();
}
inline const ::AlProto::AllMachineResourceInfo& FrameworkInstanceResourceInfo::all_machine_resource_info(int index) const {
  return all_machine_resource_info_.Get(index);
}
inline ::AlProto::AllMachineResourceInfo* FrameworkInstanceResourceInfo::mutable_all_machine_resource_info(int index) {
  return all_machine_resource_info_.Mutable(index);
}
inline ::AlProto::AllMachineResourceInfo* FrameworkInstanceResourceInfo::add_all_machine_resource_info() {
  return all_machine_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AlProto::AllMachineResourceInfo >&
FrameworkInstanceResourceInfo::all_machine_resource_info() const {
  return all_machine_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::AlProto::AllMachineResourceInfo >*
FrameworkInstanceResourceInfo::mutable_all_machine_resource_info() {
  return &all_machine_resource_info_;
}

// -------------------------------------------------------------------

// GetBusinessEntry

// required uint32 framework_instance_id = 1;
inline bool GetBusinessEntry::has_framework_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBusinessEntry::set_has_framework_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBusinessEntry::clear_has_framework_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBusinessEntry::clear_framework_instance_id() {
  framework_instance_id_ = 0u;
  clear_has_framework_instance_id();
}
inline ::google::protobuf::uint32 GetBusinessEntry::framework_instance_id() const {
  return framework_instance_id_;
}
inline void GetBusinessEntry::set_framework_instance_id(::google::protobuf::uint32 value) {
  set_has_framework_instance_id();
  framework_instance_id_ = value;
}

// -------------------------------------------------------------------

// GetBusinessEntryAck

// required string entry_ip = 1;
inline bool GetBusinessEntryAck::has_entry_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBusinessEntryAck::set_has_entry_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBusinessEntryAck::clear_has_entry_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBusinessEntryAck::clear_entry_ip() {
  if (entry_ip_ != &::google::protobuf::internal::kEmptyString) {
    entry_ip_->clear();
  }
  clear_has_entry_ip();
}
inline const ::std::string& GetBusinessEntryAck::entry_ip() const {
  return *entry_ip_;
}
inline void GetBusinessEntryAck::set_entry_ip(const ::std::string& value) {
  set_has_entry_ip();
  if (entry_ip_ == &::google::protobuf::internal::kEmptyString) {
    entry_ip_ = new ::std::string;
  }
  entry_ip_->assign(value);
}
inline void GetBusinessEntryAck::set_entry_ip(const char* value) {
  set_has_entry_ip();
  if (entry_ip_ == &::google::protobuf::internal::kEmptyString) {
    entry_ip_ = new ::std::string;
  }
  entry_ip_->assign(value);
}
inline void GetBusinessEntryAck::set_entry_ip(const char* value, size_t size) {
  set_has_entry_ip();
  if (entry_ip_ == &::google::protobuf::internal::kEmptyString) {
    entry_ip_ = new ::std::string;
  }
  entry_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBusinessEntryAck::mutable_entry_ip() {
  set_has_entry_ip();
  if (entry_ip_ == &::google::protobuf::internal::kEmptyString) {
    entry_ip_ = new ::std::string;
  }
  return entry_ip_;
}
inline ::std::string* GetBusinessEntryAck::release_entry_ip() {
  clear_has_entry_ip();
  if (entry_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entry_ip_;
    entry_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBusinessEntryAck::set_allocated_entry_ip(::std::string* entry_ip) {
  if (entry_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete entry_ip_;
  }
  if (entry_ip) {
    set_has_entry_ip();
    entry_ip_ = entry_ip;
  } else {
    clear_has_entry_ip();
    entry_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 entry_port = 2;
inline bool GetBusinessEntryAck::has_entry_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBusinessEntryAck::set_has_entry_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBusinessEntryAck::clear_has_entry_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBusinessEntryAck::clear_entry_port() {
  entry_port_ = 0u;
  clear_has_entry_port();
}
inline ::google::protobuf::uint32 GetBusinessEntryAck::entry_port() const {
  return entry_port_;
}
inline void GetBusinessEntryAck::set_entry_port(::google::protobuf::uint32 value) {
  set_has_entry_port();
  entry_port_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace AlProto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AlProtocol_2eproto__INCLUDED
