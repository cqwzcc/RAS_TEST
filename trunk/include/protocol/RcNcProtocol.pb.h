// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RcNcProtocol.proto

#ifndef PROTOBUF_RcNcProtocol_2eproto__INCLUDED
#define PROTOBUF_RcNcProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace RcNcProto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_RcNcProtocol_2eproto();
void protobuf_AssignDesc_RcNcProtocol_2eproto();
void protobuf_ShutdownFile_RcNcProtocol_2eproto();

class GpuResourceInfo;
class ResourceInfo;
class FrameworkIDInfo;
class FrameworkInstanceInfo;
class DockerImageInfo;
class NetAddress;
class Register;
class StartFrameworkRoot;
class RespondStartFrameworkRoot;
class StartSlave;
class RespondStartSlave;
class FrameworkResourceInfo;
class CloseModule;
class MachineResourceInfo;
class ContainerResourceInfo;
class MonitorInfo;

// ===================================================================

class GpuResourceInfo : public ::google::protobuf::Message {
 public:
  GpuResourceInfo();
  virtual ~GpuResourceInfo();

  GpuResourceInfo(const GpuResourceInfo& from);

  inline GpuResourceInfo& operator=(const GpuResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GpuResourceInfo& default_instance();

  void Swap(GpuResourceInfo* other);

  // implements Message ----------------------------------------------

  GpuResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpuResourceInfo& from);
  void MergeFrom(const GpuResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string gpu_name = 1;
  inline bool has_gpu_name() const;
  inline void clear_gpu_name();
  static const int kGpuNameFieldNumber = 1;
  inline const ::std::string& gpu_name() const;
  inline void set_gpu_name(const ::std::string& value);
  inline void set_gpu_name(const char* value);
  inline void set_gpu_name(const char* value, size_t size);
  inline ::std::string* mutable_gpu_name();
  inline ::std::string* release_gpu_name();
  inline void set_allocated_gpu_name(::std::string* gpu_name);

  // optional uint32 gpu_mem_size = 2;
  inline bool has_gpu_mem_size() const;
  inline void clear_gpu_mem_size();
  static const int kGpuMemSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 gpu_mem_size() const;
  inline void set_gpu_mem_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RcNcProto.GpuResourceInfo)
 private:
  inline void set_has_gpu_name();
  inline void clear_has_gpu_name();
  inline void set_has_gpu_mem_size();
  inline void clear_has_gpu_mem_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gpu_name_;
  ::google::protobuf::uint32 gpu_mem_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static GpuResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResourceInfo : public ::google::protobuf::Message {
 public:
  ResourceInfo();
  virtual ~ResourceInfo();

  ResourceInfo(const ResourceInfo& from);

  inline ResourceInfo& operator=(const ResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceInfo& default_instance();

  void Swap(ResourceInfo* other);

  // implements Message ----------------------------------------------

  ResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceInfo& from);
  void MergeFrom(const ResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double cpu_num = 1;
  inline bool has_cpu_num() const;
  inline void clear_cpu_num();
  static const int kCpuNumFieldNumber = 1;
  inline double cpu_num() const;
  inline void set_cpu_num(double value);

  // required uint32 cpu_mem_size = 2;
  inline bool has_cpu_mem_size() const;
  inline void clear_cpu_mem_size();
  static const int kCpuMemSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 cpu_mem_size() const;
  inline void set_cpu_mem_size(::google::protobuf::uint32 value);

  // optional uint32 gpu_num = 3;
  inline bool has_gpu_num() const;
  inline void clear_gpu_num();
  static const int kGpuNumFieldNumber = 3;
  inline ::google::protobuf::uint32 gpu_num() const;
  inline void set_gpu_num(::google::protobuf::uint32 value);

  // repeated .RcNcProto.GpuResourceInfo gpu_resource_info = 4;
  inline int gpu_resource_info_size() const;
  inline void clear_gpu_resource_info();
  static const int kGpuResourceInfoFieldNumber = 4;
  inline const ::RcNcProto::GpuResourceInfo& gpu_resource_info(int index) const;
  inline ::RcNcProto::GpuResourceInfo* mutable_gpu_resource_info(int index);
  inline ::RcNcProto::GpuResourceInfo* add_gpu_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::RcNcProto::GpuResourceInfo >&
      gpu_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::RcNcProto::GpuResourceInfo >*
      mutable_gpu_resource_info();

  // @@protoc_insertion_point(class_scope:RcNcProto.ResourceInfo)
 private:
  inline void set_has_cpu_num();
  inline void clear_has_cpu_num();
  inline void set_has_cpu_mem_size();
  inline void clear_has_cpu_mem_size();
  inline void set_has_gpu_num();
  inline void clear_has_gpu_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double cpu_num_;
  ::google::protobuf::uint32 cpu_mem_size_;
  ::google::protobuf::uint32 gpu_num_;
  ::google::protobuf::RepeatedPtrField< ::RcNcProto::GpuResourceInfo > gpu_resource_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static ResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkIDInfo : public ::google::protobuf::Message {
 public:
  FrameworkIDInfo();
  virtual ~FrameworkIDInfo();

  FrameworkIDInfo(const FrameworkIDInfo& from);

  inline FrameworkIDInfo& operator=(const FrameworkIDInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkIDInfo& default_instance();

  void Swap(FrameworkIDInfo* other);

  // implements Message ----------------------------------------------

  FrameworkIDInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkIDInfo& from);
  void MergeFrom(const FrameworkIDInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_id() const;
  inline void set_framework_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RcNcProto.FrameworkIDInfo)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 framework_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static FrameworkIDInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInstanceInfo : public ::google::protobuf::Message {
 public:
  FrameworkInstanceInfo();
  virtual ~FrameworkInstanceInfo();

  FrameworkInstanceInfo(const FrameworkInstanceInfo& from);

  inline FrameworkInstanceInfo& operator=(const FrameworkInstanceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInstanceInfo& default_instance();

  void Swap(FrameworkInstanceInfo* other);

  // implements Message ----------------------------------------------

  FrameworkInstanceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInstanceInfo& from);
  void MergeFrom(const FrameworkInstanceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_id() const;
  inline void set_framework_id(::google::protobuf::uint32 value);

  // required uint32 framework_instance_id = 2;
  inline bool has_framework_instance_id() const;
  inline void clear_framework_instance_id();
  static const int kFrameworkInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 framework_instance_id() const;
  inline void set_framework_instance_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RcNcProto.FrameworkInstanceInfo)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_framework_instance_id();
  inline void clear_has_framework_instance_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 framework_id_;
  ::google::protobuf::uint32 framework_instance_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static FrameworkInstanceInfo* default_instance_;
};
// -------------------------------------------------------------------

class DockerImageInfo : public ::google::protobuf::Message {
 public:
  DockerImageInfo();
  virtual ~DockerImageInfo();

  DockerImageInfo(const DockerImageInfo& from);

  inline DockerImageInfo& operator=(const DockerImageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DockerImageInfo& default_instance();

  void Swap(DockerImageInfo* other);

  // implements Message ----------------------------------------------

  DockerImageInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DockerImageInfo& from);
  void MergeFrom(const DockerImageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional string locate_file = 2;
  inline bool has_locate_file() const;
  inline void clear_locate_file();
  static const int kLocateFileFieldNumber = 2;
  inline const ::std::string& locate_file() const;
  inline void set_locate_file(const ::std::string& value);
  inline void set_locate_file(const char* value);
  inline void set_locate_file(const char* value, size_t size);
  inline ::std::string* mutable_locate_file();
  inline ::std::string* release_locate_file();
  inline void set_allocated_locate_file(::std::string* locate_file);

  // optional string module_name = 3;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 3;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  inline void set_allocated_module_name(::std::string* module_name);

  // @@protoc_insertion_point(class_scope:RcNcProto.DockerImageInfo)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_locate_file();
  inline void clear_has_locate_file();
  inline void set_has_module_name();
  inline void clear_has_module_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tag_;
  ::std::string* locate_file_;
  ::std::string* module_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static DockerImageInfo* default_instance_;
};
// -------------------------------------------------------------------

class NetAddress : public ::google::protobuf::Message {
 public:
  NetAddress();
  virtual ~NetAddress();

  NetAddress(const NetAddress& from);

  inline NetAddress& operator=(const NetAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetAddress& default_instance();

  void Swap(NetAddress* other);

  // implements Message ----------------------------------------------

  NetAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetAddress& from);
  void MergeFrom(const NetAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RcNcProto.NetAddress)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static NetAddress* default_instance_;
};
// -------------------------------------------------------------------

class Register : public ::google::protobuf::Message {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Register& default_instance();

  void Swap(Register* other);

  // implements Message ----------------------------------------------

  Register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nc_ip = 1;
  inline bool has_nc_ip() const;
  inline void clear_nc_ip();
  static const int kNcIpFieldNumber = 1;
  inline const ::std::string& nc_ip() const;
  inline void set_nc_ip(const ::std::string& value);
  inline void set_nc_ip(const char* value);
  inline void set_nc_ip(const char* value, size_t size);
  inline ::std::string* mutable_nc_ip();
  inline ::std::string* release_nc_ip();
  inline void set_allocated_nc_ip(::std::string* nc_ip);

  // optional uint32 nc_port = 2;
  inline bool has_nc_port() const;
  inline void clear_nc_port();
  static const int kNcPortFieldNumber = 2;
  inline ::google::protobuf::uint32 nc_port() const;
  inline void set_nc_port(::google::protobuf::uint32 value);

  // optional .RcNcProto.ResourceInfo machine_total_resource = 3;
  inline bool has_machine_total_resource() const;
  inline void clear_machine_total_resource();
  static const int kMachineTotalResourceFieldNumber = 3;
  inline const ::RcNcProto::ResourceInfo& machine_total_resource() const;
  inline ::RcNcProto::ResourceInfo* mutable_machine_total_resource();
  inline ::RcNcProto::ResourceInfo* release_machine_total_resource();
  inline void set_allocated_machine_total_resource(::RcNcProto::ResourceInfo* machine_total_resource);

  // @@protoc_insertion_point(class_scope:RcNcProto.Register)
 private:
  inline void set_has_nc_ip();
  inline void clear_has_nc_ip();
  inline void set_has_nc_port();
  inline void clear_has_nc_port();
  inline void set_has_machine_total_resource();
  inline void clear_has_machine_total_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nc_ip_;
  ::RcNcProto::ResourceInfo* machine_total_resource_;
  ::google::protobuf::uint32 nc_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static Register* default_instance_;
};
// -------------------------------------------------------------------

class StartFrameworkRoot : public ::google::protobuf::Message {
 public:
  StartFrameworkRoot();
  virtual ~StartFrameworkRoot();

  StartFrameworkRoot(const StartFrameworkRoot& from);

  inline StartFrameworkRoot& operator=(const StartFrameworkRoot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartFrameworkRoot& default_instance();

  void Swap(StartFrameworkRoot* other);

  // implements Message ----------------------------------------------

  StartFrameworkRoot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartFrameworkRoot& from);
  void MergeFrom(const StartFrameworkRoot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RcNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::RcNcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::RcNcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::RcNcProto::FrameworkInstanceInfo* release_framework_instance_info();
  inline void set_allocated_framework_instance_info(::RcNcProto::FrameworkInstanceInfo* framework_instance_info);

  // required uint32 self_module_id = 2;
  inline bool has_self_module_id() const;
  inline void clear_self_module_id();
  static const int kSelfModuleIdFieldNumber = 2;
  inline ::google::protobuf::uint32 self_module_id() const;
  inline void set_self_module_id(::google::protobuf::uint32 value);

  // optional .RcNcProto.DockerImageInfo docker_image_info = 3;
  inline bool has_docker_image_info() const;
  inline void clear_docker_image_info();
  static const int kDockerImageInfoFieldNumber = 3;
  inline const ::RcNcProto::DockerImageInfo& docker_image_info() const;
  inline ::RcNcProto::DockerImageInfo* mutable_docker_image_info();
  inline ::RcNcProto::DockerImageInfo* release_docker_image_info();
  inline void set_allocated_docker_image_info(::RcNcProto::DockerImageInfo* docker_image_info);

  // optional .RcNcProto.ResourceInfo require_resource = 4;
  inline bool has_require_resource() const;
  inline void clear_require_resource();
  static const int kRequireResourceFieldNumber = 4;
  inline const ::RcNcProto::ResourceInfo& require_resource() const;
  inline ::RcNcProto::ResourceInfo* mutable_require_resource();
  inline ::RcNcProto::ResourceInfo* release_require_resource();
  inline void set_allocated_require_resource(::RcNcProto::ResourceInfo* require_resource);

  // optional uint32 listen_num = 5;
  inline bool has_listen_num() const;
  inline void clear_listen_num();
  static const int kListenNumFieldNumber = 5;
  inline ::google::protobuf::uint32 listen_num() const;
  inline void set_listen_num(::google::protobuf::uint32 value);

  // optional .RcNcProto.NetAddress RC_address = 6;
  inline bool has_rc_address() const;
  inline void clear_rc_address();
  static const int kRCAddressFieldNumber = 6;
  inline const ::RcNcProto::NetAddress& rc_address() const;
  inline ::RcNcProto::NetAddress* mutable_rc_address();
  inline ::RcNcProto::NetAddress* release_rc_address();
  inline void set_allocated_rc_address(::RcNcProto::NetAddress* rc_address);

  // @@protoc_insertion_point(class_scope:RcNcProto.StartFrameworkRoot)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  inline void set_has_self_module_id();
  inline void clear_has_self_module_id();
  inline void set_has_docker_image_info();
  inline void clear_has_docker_image_info();
  inline void set_has_require_resource();
  inline void clear_has_require_resource();
  inline void set_has_listen_num();
  inline void clear_has_listen_num();
  inline void set_has_rc_address();
  inline void clear_has_rc_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::RcNcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::RcNcProto::DockerImageInfo* docker_image_info_;
  ::google::protobuf::uint32 self_module_id_;
  ::google::protobuf::uint32 listen_num_;
  ::RcNcProto::ResourceInfo* require_resource_;
  ::RcNcProto::NetAddress* rc_address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static StartFrameworkRoot* default_instance_;
};
// -------------------------------------------------------------------

class RespondStartFrameworkRoot : public ::google::protobuf::Message {
 public:
  RespondStartFrameworkRoot();
  virtual ~RespondStartFrameworkRoot();

  RespondStartFrameworkRoot(const RespondStartFrameworkRoot& from);

  inline RespondStartFrameworkRoot& operator=(const RespondStartFrameworkRoot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespondStartFrameworkRoot& default_instance();

  void Swap(RespondStartFrameworkRoot* other);

  // implements Message ----------------------------------------------

  RespondStartFrameworkRoot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespondStartFrameworkRoot& from);
  void MergeFrom(const RespondStartFrameworkRoot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RcNcProto.FrameworkInstanceInfo root_framework_instance_id = 1;
  inline bool has_root_framework_instance_id() const;
  inline void clear_root_framework_instance_id();
  static const int kRootFrameworkInstanceIdFieldNumber = 1;
  inline const ::RcNcProto::FrameworkInstanceInfo& root_framework_instance_id() const;
  inline ::RcNcProto::FrameworkInstanceInfo* mutable_root_framework_instance_id();
  inline ::RcNcProto::FrameworkInstanceInfo* release_root_framework_instance_id();
  inline void set_allocated_root_framework_instance_id(::RcNcProto::FrameworkInstanceInfo* root_framework_instance_id);

  // optional string root_ip = 2;
  inline bool has_root_ip() const;
  inline void clear_root_ip();
  static const int kRootIpFieldNumber = 2;
  inline const ::std::string& root_ip() const;
  inline void set_root_ip(const ::std::string& value);
  inline void set_root_ip(const char* value);
  inline void set_root_ip(const char* value, size_t size);
  inline ::std::string* mutable_root_ip();
  inline ::std::string* release_root_ip();
  inline void set_allocated_root_ip(::std::string* root_ip);

  // optional uint32 root_PID = 3;
  inline bool has_root_pid() const;
  inline void clear_root_pid();
  static const int kRootPIDFieldNumber = 3;
  inline ::google::protobuf::uint32 root_pid() const;
  inline void set_root_pid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RcNcProto.RespondStartFrameworkRoot)
 private:
  inline void set_has_root_framework_instance_id();
  inline void clear_has_root_framework_instance_id();
  inline void set_has_root_ip();
  inline void clear_has_root_ip();
  inline void set_has_root_pid();
  inline void clear_has_root_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::RcNcProto::FrameworkInstanceInfo* root_framework_instance_id_;
  ::std::string* root_ip_;
  ::google::protobuf::uint32 root_pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static RespondStartFrameworkRoot* default_instance_;
};
// -------------------------------------------------------------------

class StartSlave : public ::google::protobuf::Message {
 public:
  StartSlave();
  virtual ~StartSlave();

  StartSlave(const StartSlave& from);

  inline StartSlave& operator=(const StartSlave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartSlave& default_instance();

  void Swap(StartSlave* other);

  // implements Message ----------------------------------------------

  StartSlave* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartSlave& from);
  void MergeFrom(const StartSlave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RcNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::RcNcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::RcNcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::RcNcProto::FrameworkInstanceInfo* release_framework_instance_info();
  inline void set_allocated_framework_instance_info(::RcNcProto::FrameworkInstanceInfo* framework_instance_info);

  // required uint32 self_module_id = 2;
  inline bool has_self_module_id() const;
  inline void clear_self_module_id();
  static const int kSelfModuleIdFieldNumber = 2;
  inline ::google::protobuf::uint32 self_module_id() const;
  inline void set_self_module_id(::google::protobuf::uint32 value);

  // optional .RcNcProto.DockerImageInfo docker_image_info = 3;
  inline bool has_docker_image_info() const;
  inline void clear_docker_image_info();
  static const int kDockerImageInfoFieldNumber = 3;
  inline const ::RcNcProto::DockerImageInfo& docker_image_info() const;
  inline ::RcNcProto::DockerImageInfo* mutable_docker_image_info();
  inline ::RcNcProto::DockerImageInfo* release_docker_image_info();
  inline void set_allocated_docker_image_info(::RcNcProto::DockerImageInfo* docker_image_info);

  // optional .RcNcProto.ResourceInfo resource_info = 4;
  inline bool has_resource_info() const;
  inline void clear_resource_info();
  static const int kResourceInfoFieldNumber = 4;
  inline const ::RcNcProto::ResourceInfo& resource_info() const;
  inline ::RcNcProto::ResourceInfo* mutable_resource_info();
  inline ::RcNcProto::ResourceInfo* release_resource_info();
  inline void set_allocated_resource_info(::RcNcProto::ResourceInfo* resource_info);

  // optional uint32 listen_port_num = 5;
  inline bool has_listen_port_num() const;
  inline void clear_listen_port_num();
  static const int kListenPortNumFieldNumber = 5;
  inline ::google::protobuf::uint32 listen_port_num() const;
  inline void set_listen_port_num(::google::protobuf::uint32 value);

  // optional .RcNcProto.NetAddress FM_master_net_address = 6;
  inline bool has_fm_master_net_address() const;
  inline void clear_fm_master_net_address();
  static const int kFMMasterNetAddressFieldNumber = 6;
  inline const ::RcNcProto::NetAddress& fm_master_net_address() const;
  inline ::RcNcProto::NetAddress* mutable_fm_master_net_address();
  inline ::RcNcProto::NetAddress* release_fm_master_net_address();
  inline void set_allocated_fm_master_net_address(::RcNcProto::NetAddress* fm_master_net_address);

  // optional .RcNcProto.NetAddress RC_net_address = 7;
  inline bool has_rc_net_address() const;
  inline void clear_rc_net_address();
  static const int kRCNetAddressFieldNumber = 7;
  inline const ::RcNcProto::NetAddress& rc_net_address() const;
  inline ::RcNcProto::NetAddress* mutable_rc_net_address();
  inline ::RcNcProto::NetAddress* release_rc_net_address();
  inline void set_allocated_rc_net_address(::RcNcProto::NetAddress* rc_net_address);

  // @@protoc_insertion_point(class_scope:RcNcProto.StartSlave)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  inline void set_has_self_module_id();
  inline void clear_has_self_module_id();
  inline void set_has_docker_image_info();
  inline void clear_has_docker_image_info();
  inline void set_has_resource_info();
  inline void clear_has_resource_info();
  inline void set_has_listen_port_num();
  inline void clear_has_listen_port_num();
  inline void set_has_fm_master_net_address();
  inline void clear_has_fm_master_net_address();
  inline void set_has_rc_net_address();
  inline void clear_has_rc_net_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::RcNcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::RcNcProto::DockerImageInfo* docker_image_info_;
  ::google::protobuf::uint32 self_module_id_;
  ::google::protobuf::uint32 listen_port_num_;
  ::RcNcProto::ResourceInfo* resource_info_;
  ::RcNcProto::NetAddress* fm_master_net_address_;
  ::RcNcProto::NetAddress* rc_net_address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static StartSlave* default_instance_;
};
// -------------------------------------------------------------------

class RespondStartSlave : public ::google::protobuf::Message {
 public:
  RespondStartSlave();
  virtual ~RespondStartSlave();

  RespondStartSlave(const RespondStartSlave& from);

  inline RespondStartSlave& operator=(const RespondStartSlave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespondStartSlave& default_instance();

  void Swap(RespondStartSlave* other);

  // implements Message ----------------------------------------------

  RespondStartSlave* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespondStartSlave& from);
  void MergeFrom(const RespondStartSlave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RcNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::RcNcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::RcNcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::RcNcProto::FrameworkInstanceInfo* release_framework_instance_info();
  inline void set_allocated_framework_instance_info(::RcNcProto::FrameworkInstanceInfo* framework_instance_info);

  // required uint32 self_module_id = 2;
  inline bool has_self_module_id() const;
  inline void clear_self_module_id();
  static const int kSelfModuleIdFieldNumber = 2;
  inline ::google::protobuf::uint32 self_module_id() const;
  inline void set_self_module_id(::google::protobuf::uint32 value);

  // optional string machine_ip = 3;
  inline bool has_machine_ip() const;
  inline void clear_machine_ip();
  static const int kMachineIpFieldNumber = 3;
  inline const ::std::string& machine_ip() const;
  inline void set_machine_ip(const ::std::string& value);
  inline void set_machine_ip(const char* value);
  inline void set_machine_ip(const char* value, size_t size);
  inline ::std::string* mutable_machine_ip();
  inline ::std::string* release_machine_ip();
  inline void set_allocated_machine_ip(::std::string* machine_ip);

  // optional uint32 module_PID = 4;
  inline bool has_module_pid() const;
  inline void clear_module_pid();
  static const int kModulePIDFieldNumber = 4;
  inline ::google::protobuf::uint32 module_pid() const;
  inline void set_module_pid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RcNcProto.RespondStartSlave)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  inline void set_has_self_module_id();
  inline void clear_has_self_module_id();
  inline void set_has_machine_ip();
  inline void clear_has_machine_ip();
  inline void set_has_module_pid();
  inline void clear_has_module_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::RcNcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::std::string* machine_ip_;
  ::google::protobuf::uint32 self_module_id_;
  ::google::protobuf::uint32 module_pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static RespondStartSlave* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkResourceInfo : public ::google::protobuf::Message {
 public:
  FrameworkResourceInfo();
  virtual ~FrameworkResourceInfo();

  FrameworkResourceInfo(const FrameworkResourceInfo& from);

  inline FrameworkResourceInfo& operator=(const FrameworkResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkResourceInfo& default_instance();

  void Swap(FrameworkResourceInfo* other);

  // implements Message ----------------------------------------------

  FrameworkResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkResourceInfo& from);
  void MergeFrom(const FrameworkResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RcNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::RcNcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::RcNcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::RcNcProto::FrameworkInstanceInfo* release_framework_instance_info();
  inline void set_allocated_framework_instance_info(::RcNcProto::FrameworkInstanceInfo* framework_instance_info);

  // optional .RcNcProto.ResourceInfo resource_info = 2;
  inline bool has_resource_info() const;
  inline void clear_resource_info();
  static const int kResourceInfoFieldNumber = 2;
  inline const ::RcNcProto::ResourceInfo& resource_info() const;
  inline ::RcNcProto::ResourceInfo* mutable_resource_info();
  inline ::RcNcProto::ResourceInfo* release_resource_info();
  inline void set_allocated_resource_info(::RcNcProto::ResourceInfo* resource_info);

  // optional uint32 module_PID = 3;
  inline bool has_module_pid() const;
  inline void clear_module_pid();
  static const int kModulePIDFieldNumber = 3;
  inline ::google::protobuf::uint32 module_pid() const;
  inline void set_module_pid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RcNcProto.FrameworkResourceInfo)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  inline void set_has_resource_info();
  inline void clear_has_resource_info();
  inline void set_has_module_pid();
  inline void clear_has_module_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::RcNcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::RcNcProto::ResourceInfo* resource_info_;
  ::google::protobuf::uint32 module_pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static FrameworkResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class CloseModule : public ::google::protobuf::Message {
 public:
  CloseModule();
  virtual ~CloseModule();

  CloseModule(const CloseModule& from);

  inline CloseModule& operator=(const CloseModule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseModule& default_instance();

  void Swap(CloseModule* other);

  // implements Message ----------------------------------------------

  CloseModule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseModule& from);
  void MergeFrom(const CloseModule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RcNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::RcNcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::RcNcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::RcNcProto::FrameworkInstanceInfo* release_framework_instance_info();
  inline void set_allocated_framework_instance_info(::RcNcProto::FrameworkInstanceInfo* framework_instance_info);

  // repeated uint32 module_PID = 2;
  inline int module_pid_size() const;
  inline void clear_module_pid();
  static const int kModulePIDFieldNumber = 2;
  inline ::google::protobuf::uint32 module_pid(int index) const;
  inline void set_module_pid(int index, ::google::protobuf::uint32 value);
  inline void add_module_pid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      module_pid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_module_pid();

  // @@protoc_insertion_point(class_scope:RcNcProto.CloseModule)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::RcNcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > module_pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static CloseModule* default_instance_;
};
// -------------------------------------------------------------------

class MachineResourceInfo : public ::google::protobuf::Message {
 public:
  MachineResourceInfo();
  virtual ~MachineResourceInfo();

  MachineResourceInfo(const MachineResourceInfo& from);

  inline MachineResourceInfo& operator=(const MachineResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineResourceInfo& default_instance();

  void Swap(MachineResourceInfo* other);

  // implements Message ----------------------------------------------

  MachineResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MachineResourceInfo& from);
  void MergeFrom(const MachineResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cpu_mem_size = 1;
  inline bool has_cpu_mem_size() const;
  inline void clear_cpu_mem_size();
  static const int kCpuMemSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 cpu_mem_size() const;
  inline void set_cpu_mem_size(::google::protobuf::uint32 value);

  // optional double cpu_num = 2;
  inline bool has_cpu_num() const;
  inline void clear_cpu_num();
  static const int kCpuNumFieldNumber = 2;
  inline double cpu_num() const;
  inline void set_cpu_num(double value);

  // optional uint32 net_speed = 3;
  inline bool has_net_speed() const;
  inline void clear_net_speed();
  static const int kNetSpeedFieldNumber = 3;
  inline ::google::protobuf::uint32 net_speed() const;
  inline void set_net_speed(::google::protobuf::uint32 value);

  // optional uint32 disk_size = 4;
  inline bool has_disk_size() const;
  inline void clear_disk_size();
  static const int kDiskSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 disk_size() const;
  inline void set_disk_size(::google::protobuf::uint32 value);

  // optional uint32 gpu_num = 5;
  inline bool has_gpu_num() const;
  inline void clear_gpu_num();
  static const int kGpuNumFieldNumber = 5;
  inline ::google::protobuf::uint32 gpu_num() const;
  inline void set_gpu_num(::google::protobuf::uint32 value);

  // repeated .RcNcProto.GpuResourceInfo gpu_resource_info = 6;
  inline int gpu_resource_info_size() const;
  inline void clear_gpu_resource_info();
  static const int kGpuResourceInfoFieldNumber = 6;
  inline const ::RcNcProto::GpuResourceInfo& gpu_resource_info(int index) const;
  inline ::RcNcProto::GpuResourceInfo* mutable_gpu_resource_info(int index);
  inline ::RcNcProto::GpuResourceInfo* add_gpu_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::RcNcProto::GpuResourceInfo >&
      gpu_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::RcNcProto::GpuResourceInfo >*
      mutable_gpu_resource_info();

  // @@protoc_insertion_point(class_scope:RcNcProto.MachineResourceInfo)
 private:
  inline void set_has_cpu_mem_size();
  inline void clear_has_cpu_mem_size();
  inline void set_has_cpu_num();
  inline void clear_has_cpu_num();
  inline void set_has_net_speed();
  inline void clear_has_net_speed();
  inline void set_has_disk_size();
  inline void clear_has_disk_size();
  inline void set_has_gpu_num();
  inline void clear_has_gpu_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double cpu_num_;
  ::google::protobuf::uint32 cpu_mem_size_;
  ::google::protobuf::uint32 net_speed_;
  ::google::protobuf::uint32 disk_size_;
  ::google::protobuf::uint32 gpu_num_;
  ::google::protobuf::RepeatedPtrField< ::RcNcProto::GpuResourceInfo > gpu_resource_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static MachineResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContainerResourceInfo : public ::google::protobuf::Message {
 public:
  ContainerResourceInfo();
  virtual ~ContainerResourceInfo();

  ContainerResourceInfo(const ContainerResourceInfo& from);

  inline ContainerResourceInfo& operator=(const ContainerResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerResourceInfo& default_instance();

  void Swap(ContainerResourceInfo* other);

  // implements Message ----------------------------------------------

  ContainerResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerResourceInfo& from);
  void MergeFrom(const ContainerResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 framework_instance_id = 1;
  inline bool has_framework_instance_id() const;
  inline void clear_framework_instance_id();
  static const int kFrameworkInstanceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_instance_id() const;
  inline void set_framework_instance_id(::google::protobuf::uint32 value);

  // optional .RcNcProto.ResourceInfo resource_info = 2;
  inline bool has_resource_info() const;
  inline void clear_resource_info();
  static const int kResourceInfoFieldNumber = 2;
  inline const ::RcNcProto::ResourceInfo& resource_info() const;
  inline ::RcNcProto::ResourceInfo* mutable_resource_info();
  inline ::RcNcProto::ResourceInfo* release_resource_info();
  inline void set_allocated_resource_info(::RcNcProto::ResourceInfo* resource_info);

  // @@protoc_insertion_point(class_scope:RcNcProto.ContainerResourceInfo)
 private:
  inline void set_has_framework_instance_id();
  inline void clear_has_framework_instance_id();
  inline void set_has_resource_info();
  inline void clear_has_resource_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::RcNcProto::ResourceInfo* resource_info_;
  ::google::protobuf::uint32 framework_instance_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static ContainerResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MonitorInfo : public ::google::protobuf::Message {
 public:
  MonitorInfo();
  virtual ~MonitorInfo();

  MonitorInfo(const MonitorInfo& from);

  inline MonitorInfo& operator=(const MonitorInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MonitorInfo& default_instance();

  void Swap(MonitorInfo* other);

  // implements Message ----------------------------------------------

  MonitorInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MonitorInfo& from);
  void MergeFrom(const MonitorInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RcNcProto.MachineResourceInfo total_machine_resource_info = 1;
  inline bool has_total_machine_resource_info() const;
  inline void clear_total_machine_resource_info();
  static const int kTotalMachineResourceInfoFieldNumber = 1;
  inline const ::RcNcProto::MachineResourceInfo& total_machine_resource_info() const;
  inline ::RcNcProto::MachineResourceInfo* mutable_total_machine_resource_info();
  inline ::RcNcProto::MachineResourceInfo* release_total_machine_resource_info();
  inline void set_allocated_total_machine_resource_info(::RcNcProto::MachineResourceInfo* total_machine_resource_info);

  // optional .RcNcProto.MachineResourceInfo usage_machine_resource_info = 2;
  inline bool has_usage_machine_resource_info() const;
  inline void clear_usage_machine_resource_info();
  static const int kUsageMachineResourceInfoFieldNumber = 2;
  inline const ::RcNcProto::MachineResourceInfo& usage_machine_resource_info() const;
  inline ::RcNcProto::MachineResourceInfo* mutable_usage_machine_resource_info();
  inline ::RcNcProto::MachineResourceInfo* release_usage_machine_resource_info();
  inline void set_allocated_usage_machine_resource_info(::RcNcProto::MachineResourceInfo* usage_machine_resource_info);

  // optional .RcNcProto.ResourceInfo rest_machine_resource_info = 3;
  inline bool has_rest_machine_resource_info() const;
  inline void clear_rest_machine_resource_info();
  static const int kRestMachineResourceInfoFieldNumber = 3;
  inline const ::RcNcProto::ResourceInfo& rest_machine_resource_info() const;
  inline ::RcNcProto::ResourceInfo* mutable_rest_machine_resource_info();
  inline ::RcNcProto::ResourceInfo* release_rest_machine_resource_info();
  inline void set_allocated_rest_machine_resource_info(::RcNcProto::ResourceInfo* rest_machine_resource_info);

  // repeated .RcNcProto.ContainerResourceInfo container_require_resource_info = 4;
  inline int container_require_resource_info_size() const;
  inline void clear_container_require_resource_info();
  static const int kContainerRequireResourceInfoFieldNumber = 4;
  inline const ::RcNcProto::ContainerResourceInfo& container_require_resource_info(int index) const;
  inline ::RcNcProto::ContainerResourceInfo* mutable_container_require_resource_info(int index);
  inline ::RcNcProto::ContainerResourceInfo* add_container_require_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::RcNcProto::ContainerResourceInfo >&
      container_require_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::RcNcProto::ContainerResourceInfo >*
      mutable_container_require_resource_info();

  // repeated .RcNcProto.ContainerResourceInfo container_usage_resource_info = 5;
  inline int container_usage_resource_info_size() const;
  inline void clear_container_usage_resource_info();
  static const int kContainerUsageResourceInfoFieldNumber = 5;
  inline const ::RcNcProto::ContainerResourceInfo& container_usage_resource_info(int index) const;
  inline ::RcNcProto::ContainerResourceInfo* mutable_container_usage_resource_info(int index);
  inline ::RcNcProto::ContainerResourceInfo* add_container_usage_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::RcNcProto::ContainerResourceInfo >&
      container_usage_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::RcNcProto::ContainerResourceInfo >*
      mutable_container_usage_resource_info();

  // repeated uint32 crash_moudle_id = 6;
  inline int crash_moudle_id_size() const;
  inline void clear_crash_moudle_id();
  static const int kCrashMoudleIdFieldNumber = 6;
  inline ::google::protobuf::uint32 crash_moudle_id(int index) const;
  inline void set_crash_moudle_id(int index, ::google::protobuf::uint32 value);
  inline void add_crash_moudle_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      crash_moudle_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_crash_moudle_id();

  // @@protoc_insertion_point(class_scope:RcNcProto.MonitorInfo)
 private:
  inline void set_has_total_machine_resource_info();
  inline void clear_has_total_machine_resource_info();
  inline void set_has_usage_machine_resource_info();
  inline void clear_has_usage_machine_resource_info();
  inline void set_has_rest_machine_resource_info();
  inline void clear_has_rest_machine_resource_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::RcNcProto::MachineResourceInfo* total_machine_resource_info_;
  ::RcNcProto::MachineResourceInfo* usage_machine_resource_info_;
  ::RcNcProto::ResourceInfo* rest_machine_resource_info_;
  ::google::protobuf::RepeatedPtrField< ::RcNcProto::ContainerResourceInfo > container_require_resource_info_;
  ::google::protobuf::RepeatedPtrField< ::RcNcProto::ContainerResourceInfo > container_usage_resource_info_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > crash_moudle_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_RcNcProtocol_2eproto();
  friend void protobuf_AssignDesc_RcNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_RcNcProtocol_2eproto();

  void InitAsDefaultInstance();
  static MonitorInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// GpuResourceInfo

// required string gpu_name = 1;
inline bool GpuResourceInfo::has_gpu_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuResourceInfo::set_has_gpu_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuResourceInfo::clear_has_gpu_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuResourceInfo::clear_gpu_name() {
  if (gpu_name_ != &::google::protobuf::internal::kEmptyString) {
    gpu_name_->clear();
  }
  clear_has_gpu_name();
}
inline const ::std::string& GpuResourceInfo::gpu_name() const {
  return *gpu_name_;
}
inline void GpuResourceInfo::set_gpu_name(const ::std::string& value) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(value);
}
inline void GpuResourceInfo::set_gpu_name(const char* value) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(value);
}
inline void GpuResourceInfo::set_gpu_name(const char* value, size_t size) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpuResourceInfo::mutable_gpu_name() {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  return gpu_name_;
}
inline ::std::string* GpuResourceInfo::release_gpu_name() {
  clear_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gpu_name_;
    gpu_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GpuResourceInfo::set_allocated_gpu_name(::std::string* gpu_name) {
  if (gpu_name_ != &::google::protobuf::internal::kEmptyString) {
    delete gpu_name_;
  }
  if (gpu_name) {
    set_has_gpu_name();
    gpu_name_ = gpu_name;
  } else {
    clear_has_gpu_name();
    gpu_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gpu_mem_size = 2;
inline bool GpuResourceInfo::has_gpu_mem_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuResourceInfo::set_has_gpu_mem_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuResourceInfo::clear_has_gpu_mem_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuResourceInfo::clear_gpu_mem_size() {
  gpu_mem_size_ = 0u;
  clear_has_gpu_mem_size();
}
inline ::google::protobuf::uint32 GpuResourceInfo::gpu_mem_size() const {
  return gpu_mem_size_;
}
inline void GpuResourceInfo::set_gpu_mem_size(::google::protobuf::uint32 value) {
  set_has_gpu_mem_size();
  gpu_mem_size_ = value;
}

// -------------------------------------------------------------------

// ResourceInfo

// required double cpu_num = 1;
inline bool ResourceInfo::has_cpu_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceInfo::set_has_cpu_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceInfo::clear_has_cpu_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceInfo::clear_cpu_num() {
  cpu_num_ = 0;
  clear_has_cpu_num();
}
inline double ResourceInfo::cpu_num() const {
  return cpu_num_;
}
inline void ResourceInfo::set_cpu_num(double value) {
  set_has_cpu_num();
  cpu_num_ = value;
}

// required uint32 cpu_mem_size = 2;
inline bool ResourceInfo::has_cpu_mem_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceInfo::set_has_cpu_mem_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceInfo::clear_has_cpu_mem_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceInfo::clear_cpu_mem_size() {
  cpu_mem_size_ = 0u;
  clear_has_cpu_mem_size();
}
inline ::google::protobuf::uint32 ResourceInfo::cpu_mem_size() const {
  return cpu_mem_size_;
}
inline void ResourceInfo::set_cpu_mem_size(::google::protobuf::uint32 value) {
  set_has_cpu_mem_size();
  cpu_mem_size_ = value;
}

// optional uint32 gpu_num = 3;
inline bool ResourceInfo::has_gpu_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceInfo::set_has_gpu_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceInfo::clear_has_gpu_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceInfo::clear_gpu_num() {
  gpu_num_ = 0u;
  clear_has_gpu_num();
}
inline ::google::protobuf::uint32 ResourceInfo::gpu_num() const {
  return gpu_num_;
}
inline void ResourceInfo::set_gpu_num(::google::protobuf::uint32 value) {
  set_has_gpu_num();
  gpu_num_ = value;
}

// repeated .RcNcProto.GpuResourceInfo gpu_resource_info = 4;
inline int ResourceInfo::gpu_resource_info_size() const {
  return gpu_resource_info_.size();
}
inline void ResourceInfo::clear_gpu_resource_info() {
  gpu_resource_info_.Clear();
}
inline const ::RcNcProto::GpuResourceInfo& ResourceInfo::gpu_resource_info(int index) const {
  return gpu_resource_info_.Get(index);
}
inline ::RcNcProto::GpuResourceInfo* ResourceInfo::mutable_gpu_resource_info(int index) {
  return gpu_resource_info_.Mutable(index);
}
inline ::RcNcProto::GpuResourceInfo* ResourceInfo::add_gpu_resource_info() {
  return gpu_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RcNcProto::GpuResourceInfo >&
ResourceInfo::gpu_resource_info() const {
  return gpu_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::RcNcProto::GpuResourceInfo >*
ResourceInfo::mutable_gpu_resource_info() {
  return &gpu_resource_info_;
}

// -------------------------------------------------------------------

// FrameworkIDInfo

// required uint32 framework_id = 1;
inline bool FrameworkIDInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkIDInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkIDInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkIDInfo::clear_framework_id() {
  framework_id_ = 0u;
  clear_has_framework_id();
}
inline ::google::protobuf::uint32 FrameworkIDInfo::framework_id() const {
  return framework_id_;
}
inline void FrameworkIDInfo::set_framework_id(::google::protobuf::uint32 value) {
  set_has_framework_id();
  framework_id_ = value;
}

// -------------------------------------------------------------------

// FrameworkInstanceInfo

// required uint32 framework_id = 1;
inline bool FrameworkInstanceInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInstanceInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInstanceInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInstanceInfo::clear_framework_id() {
  framework_id_ = 0u;
  clear_has_framework_id();
}
inline ::google::protobuf::uint32 FrameworkInstanceInfo::framework_id() const {
  return framework_id_;
}
inline void FrameworkInstanceInfo::set_framework_id(::google::protobuf::uint32 value) {
  set_has_framework_id();
  framework_id_ = value;
}

// required uint32 framework_instance_id = 2;
inline bool FrameworkInstanceInfo::has_framework_instance_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkInstanceInfo::set_has_framework_instance_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkInstanceInfo::clear_has_framework_instance_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkInstanceInfo::clear_framework_instance_id() {
  framework_instance_id_ = 0u;
  clear_has_framework_instance_id();
}
inline ::google::protobuf::uint32 FrameworkInstanceInfo::framework_instance_id() const {
  return framework_instance_id_;
}
inline void FrameworkInstanceInfo::set_framework_instance_id(::google::protobuf::uint32 value) {
  set_has_framework_instance_id();
  framework_instance_id_ = value;
}

// -------------------------------------------------------------------

// DockerImageInfo

// required string tag = 1;
inline bool DockerImageInfo::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DockerImageInfo::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DockerImageInfo::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DockerImageInfo::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& DockerImageInfo::tag() const {
  return *tag_;
}
inline void DockerImageInfo::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void DockerImageInfo::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void DockerImageInfo::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageInfo::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* DockerImageInfo::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageInfo::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string locate_file = 2;
inline bool DockerImageInfo::has_locate_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DockerImageInfo::set_has_locate_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DockerImageInfo::clear_has_locate_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DockerImageInfo::clear_locate_file() {
  if (locate_file_ != &::google::protobuf::internal::kEmptyString) {
    locate_file_->clear();
  }
  clear_has_locate_file();
}
inline const ::std::string& DockerImageInfo::locate_file() const {
  return *locate_file_;
}
inline void DockerImageInfo::set_locate_file(const ::std::string& value) {
  set_has_locate_file();
  if (locate_file_ == &::google::protobuf::internal::kEmptyString) {
    locate_file_ = new ::std::string;
  }
  locate_file_->assign(value);
}
inline void DockerImageInfo::set_locate_file(const char* value) {
  set_has_locate_file();
  if (locate_file_ == &::google::protobuf::internal::kEmptyString) {
    locate_file_ = new ::std::string;
  }
  locate_file_->assign(value);
}
inline void DockerImageInfo::set_locate_file(const char* value, size_t size) {
  set_has_locate_file();
  if (locate_file_ == &::google::protobuf::internal::kEmptyString) {
    locate_file_ = new ::std::string;
  }
  locate_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageInfo::mutable_locate_file() {
  set_has_locate_file();
  if (locate_file_ == &::google::protobuf::internal::kEmptyString) {
    locate_file_ = new ::std::string;
  }
  return locate_file_;
}
inline ::std::string* DockerImageInfo::release_locate_file() {
  clear_has_locate_file();
  if (locate_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locate_file_;
    locate_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageInfo::set_allocated_locate_file(::std::string* locate_file) {
  if (locate_file_ != &::google::protobuf::internal::kEmptyString) {
    delete locate_file_;
  }
  if (locate_file) {
    set_has_locate_file();
    locate_file_ = locate_file;
  } else {
    clear_has_locate_file();
    locate_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string module_name = 3;
inline bool DockerImageInfo::has_module_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DockerImageInfo::set_has_module_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DockerImageInfo::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DockerImageInfo::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& DockerImageInfo::module_name() const {
  return *module_name_;
}
inline void DockerImageInfo::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void DockerImageInfo::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void DockerImageInfo::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageInfo::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  return module_name_;
}
inline ::std::string* DockerImageInfo::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageInfo::set_allocated_module_name(::std::string* module_name) {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    delete module_name_;
  }
  if (module_name) {
    set_has_module_name();
    module_name_ = module_name;
  } else {
    clear_has_module_name();
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NetAddress

// required string ip = 1;
inline bool NetAddress::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetAddress::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetAddress::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetAddress::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& NetAddress::ip() const {
  return *ip_;
}
inline void NetAddress::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NetAddress::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NetAddress::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetAddress::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* NetAddress::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NetAddress::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 2;
inline bool NetAddress::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetAddress::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetAddress::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetAddress::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 NetAddress::port() const {
  return port_;
}
inline void NetAddress::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// Register

// required string nc_ip = 1;
inline bool Register::has_nc_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Register::set_has_nc_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Register::clear_has_nc_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Register::clear_nc_ip() {
  if (nc_ip_ != &::google::protobuf::internal::kEmptyString) {
    nc_ip_->clear();
  }
  clear_has_nc_ip();
}
inline const ::std::string& Register::nc_ip() const {
  return *nc_ip_;
}
inline void Register::set_nc_ip(const ::std::string& value) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(value);
}
inline void Register::set_nc_ip(const char* value) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(value);
}
inline void Register::set_nc_ip(const char* value, size_t size) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_nc_ip() {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  return nc_ip_;
}
inline ::std::string* Register::release_nc_ip() {
  clear_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nc_ip_;
    nc_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_nc_ip(::std::string* nc_ip) {
  if (nc_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete nc_ip_;
  }
  if (nc_ip) {
    set_has_nc_ip();
    nc_ip_ = nc_ip;
  } else {
    clear_has_nc_ip();
    nc_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 nc_port = 2;
inline bool Register::has_nc_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Register::set_has_nc_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Register::clear_has_nc_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Register::clear_nc_port() {
  nc_port_ = 0u;
  clear_has_nc_port();
}
inline ::google::protobuf::uint32 Register::nc_port() const {
  return nc_port_;
}
inline void Register::set_nc_port(::google::protobuf::uint32 value) {
  set_has_nc_port();
  nc_port_ = value;
}

// optional .RcNcProto.ResourceInfo machine_total_resource = 3;
inline bool Register::has_machine_total_resource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Register::set_has_machine_total_resource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Register::clear_has_machine_total_resource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Register::clear_machine_total_resource() {
  if (machine_total_resource_ != NULL) machine_total_resource_->::RcNcProto::ResourceInfo::Clear();
  clear_has_machine_total_resource();
}
inline const ::RcNcProto::ResourceInfo& Register::machine_total_resource() const {
  return machine_total_resource_ != NULL ? *machine_total_resource_ : *default_instance_->machine_total_resource_;
}
inline ::RcNcProto::ResourceInfo* Register::mutable_machine_total_resource() {
  set_has_machine_total_resource();
  if (machine_total_resource_ == NULL) machine_total_resource_ = new ::RcNcProto::ResourceInfo;
  return machine_total_resource_;
}
inline ::RcNcProto::ResourceInfo* Register::release_machine_total_resource() {
  clear_has_machine_total_resource();
  ::RcNcProto::ResourceInfo* temp = machine_total_resource_;
  machine_total_resource_ = NULL;
  return temp;
}
inline void Register::set_allocated_machine_total_resource(::RcNcProto::ResourceInfo* machine_total_resource) {
  delete machine_total_resource_;
  machine_total_resource_ = machine_total_resource;
  if (machine_total_resource) {
    set_has_machine_total_resource();
  } else {
    clear_has_machine_total_resource();
  }
}

// -------------------------------------------------------------------

// StartFrameworkRoot

// required .RcNcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool StartFrameworkRoot::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartFrameworkRoot::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartFrameworkRoot::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartFrameworkRoot::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::RcNcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::RcNcProto::FrameworkInstanceInfo& StartFrameworkRoot::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::RcNcProto::FrameworkInstanceInfo* StartFrameworkRoot::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::RcNcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::RcNcProto::FrameworkInstanceInfo* StartFrameworkRoot::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::RcNcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}
inline void StartFrameworkRoot::set_allocated_framework_instance_info(::RcNcProto::FrameworkInstanceInfo* framework_instance_info) {
  delete framework_instance_info_;
  framework_instance_info_ = framework_instance_info;
  if (framework_instance_info) {
    set_has_framework_instance_info();
  } else {
    clear_has_framework_instance_info();
  }
}

// required uint32 self_module_id = 2;
inline bool StartFrameworkRoot::has_self_module_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartFrameworkRoot::set_has_self_module_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartFrameworkRoot::clear_has_self_module_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartFrameworkRoot::clear_self_module_id() {
  self_module_id_ = 0u;
  clear_has_self_module_id();
}
inline ::google::protobuf::uint32 StartFrameworkRoot::self_module_id() const {
  return self_module_id_;
}
inline void StartFrameworkRoot::set_self_module_id(::google::protobuf::uint32 value) {
  set_has_self_module_id();
  self_module_id_ = value;
}

// optional .RcNcProto.DockerImageInfo docker_image_info = 3;
inline bool StartFrameworkRoot::has_docker_image_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartFrameworkRoot::set_has_docker_image_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartFrameworkRoot::clear_has_docker_image_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartFrameworkRoot::clear_docker_image_info() {
  if (docker_image_info_ != NULL) docker_image_info_->::RcNcProto::DockerImageInfo::Clear();
  clear_has_docker_image_info();
}
inline const ::RcNcProto::DockerImageInfo& StartFrameworkRoot::docker_image_info() const {
  return docker_image_info_ != NULL ? *docker_image_info_ : *default_instance_->docker_image_info_;
}
inline ::RcNcProto::DockerImageInfo* StartFrameworkRoot::mutable_docker_image_info() {
  set_has_docker_image_info();
  if (docker_image_info_ == NULL) docker_image_info_ = new ::RcNcProto::DockerImageInfo;
  return docker_image_info_;
}
inline ::RcNcProto::DockerImageInfo* StartFrameworkRoot::release_docker_image_info() {
  clear_has_docker_image_info();
  ::RcNcProto::DockerImageInfo* temp = docker_image_info_;
  docker_image_info_ = NULL;
  return temp;
}
inline void StartFrameworkRoot::set_allocated_docker_image_info(::RcNcProto::DockerImageInfo* docker_image_info) {
  delete docker_image_info_;
  docker_image_info_ = docker_image_info;
  if (docker_image_info) {
    set_has_docker_image_info();
  } else {
    clear_has_docker_image_info();
  }
}

// optional .RcNcProto.ResourceInfo require_resource = 4;
inline bool StartFrameworkRoot::has_require_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartFrameworkRoot::set_has_require_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartFrameworkRoot::clear_has_require_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartFrameworkRoot::clear_require_resource() {
  if (require_resource_ != NULL) require_resource_->::RcNcProto::ResourceInfo::Clear();
  clear_has_require_resource();
}
inline const ::RcNcProto::ResourceInfo& StartFrameworkRoot::require_resource() const {
  return require_resource_ != NULL ? *require_resource_ : *default_instance_->require_resource_;
}
inline ::RcNcProto::ResourceInfo* StartFrameworkRoot::mutable_require_resource() {
  set_has_require_resource();
  if (require_resource_ == NULL) require_resource_ = new ::RcNcProto::ResourceInfo;
  return require_resource_;
}
inline ::RcNcProto::ResourceInfo* StartFrameworkRoot::release_require_resource() {
  clear_has_require_resource();
  ::RcNcProto::ResourceInfo* temp = require_resource_;
  require_resource_ = NULL;
  return temp;
}
inline void StartFrameworkRoot::set_allocated_require_resource(::RcNcProto::ResourceInfo* require_resource) {
  delete require_resource_;
  require_resource_ = require_resource;
  if (require_resource) {
    set_has_require_resource();
  } else {
    clear_has_require_resource();
  }
}

// optional uint32 listen_num = 5;
inline bool StartFrameworkRoot::has_listen_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartFrameworkRoot::set_has_listen_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartFrameworkRoot::clear_has_listen_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartFrameworkRoot::clear_listen_num() {
  listen_num_ = 0u;
  clear_has_listen_num();
}
inline ::google::protobuf::uint32 StartFrameworkRoot::listen_num() const {
  return listen_num_;
}
inline void StartFrameworkRoot::set_listen_num(::google::protobuf::uint32 value) {
  set_has_listen_num();
  listen_num_ = value;
}

// optional .RcNcProto.NetAddress RC_address = 6;
inline bool StartFrameworkRoot::has_rc_address() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StartFrameworkRoot::set_has_rc_address() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StartFrameworkRoot::clear_has_rc_address() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StartFrameworkRoot::clear_rc_address() {
  if (rc_address_ != NULL) rc_address_->::RcNcProto::NetAddress::Clear();
  clear_has_rc_address();
}
inline const ::RcNcProto::NetAddress& StartFrameworkRoot::rc_address() const {
  return rc_address_ != NULL ? *rc_address_ : *default_instance_->rc_address_;
}
inline ::RcNcProto::NetAddress* StartFrameworkRoot::mutable_rc_address() {
  set_has_rc_address();
  if (rc_address_ == NULL) rc_address_ = new ::RcNcProto::NetAddress;
  return rc_address_;
}
inline ::RcNcProto::NetAddress* StartFrameworkRoot::release_rc_address() {
  clear_has_rc_address();
  ::RcNcProto::NetAddress* temp = rc_address_;
  rc_address_ = NULL;
  return temp;
}
inline void StartFrameworkRoot::set_allocated_rc_address(::RcNcProto::NetAddress* rc_address) {
  delete rc_address_;
  rc_address_ = rc_address;
  if (rc_address) {
    set_has_rc_address();
  } else {
    clear_has_rc_address();
  }
}

// -------------------------------------------------------------------

// RespondStartFrameworkRoot

// required .RcNcProto.FrameworkInstanceInfo root_framework_instance_id = 1;
inline bool RespondStartFrameworkRoot::has_root_framework_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespondStartFrameworkRoot::set_has_root_framework_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespondStartFrameworkRoot::clear_has_root_framework_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespondStartFrameworkRoot::clear_root_framework_instance_id() {
  if (root_framework_instance_id_ != NULL) root_framework_instance_id_->::RcNcProto::FrameworkInstanceInfo::Clear();
  clear_has_root_framework_instance_id();
}
inline const ::RcNcProto::FrameworkInstanceInfo& RespondStartFrameworkRoot::root_framework_instance_id() const {
  return root_framework_instance_id_ != NULL ? *root_framework_instance_id_ : *default_instance_->root_framework_instance_id_;
}
inline ::RcNcProto::FrameworkInstanceInfo* RespondStartFrameworkRoot::mutable_root_framework_instance_id() {
  set_has_root_framework_instance_id();
  if (root_framework_instance_id_ == NULL) root_framework_instance_id_ = new ::RcNcProto::FrameworkInstanceInfo;
  return root_framework_instance_id_;
}
inline ::RcNcProto::FrameworkInstanceInfo* RespondStartFrameworkRoot::release_root_framework_instance_id() {
  clear_has_root_framework_instance_id();
  ::RcNcProto::FrameworkInstanceInfo* temp = root_framework_instance_id_;
  root_framework_instance_id_ = NULL;
  return temp;
}
inline void RespondStartFrameworkRoot::set_allocated_root_framework_instance_id(::RcNcProto::FrameworkInstanceInfo* root_framework_instance_id) {
  delete root_framework_instance_id_;
  root_framework_instance_id_ = root_framework_instance_id;
  if (root_framework_instance_id) {
    set_has_root_framework_instance_id();
  } else {
    clear_has_root_framework_instance_id();
  }
}

// optional string root_ip = 2;
inline bool RespondStartFrameworkRoot::has_root_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespondStartFrameworkRoot::set_has_root_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespondStartFrameworkRoot::clear_has_root_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespondStartFrameworkRoot::clear_root_ip() {
  if (root_ip_ != &::google::protobuf::internal::kEmptyString) {
    root_ip_->clear();
  }
  clear_has_root_ip();
}
inline const ::std::string& RespondStartFrameworkRoot::root_ip() const {
  return *root_ip_;
}
inline void RespondStartFrameworkRoot::set_root_ip(const ::std::string& value) {
  set_has_root_ip();
  if (root_ip_ == &::google::protobuf::internal::kEmptyString) {
    root_ip_ = new ::std::string;
  }
  root_ip_->assign(value);
}
inline void RespondStartFrameworkRoot::set_root_ip(const char* value) {
  set_has_root_ip();
  if (root_ip_ == &::google::protobuf::internal::kEmptyString) {
    root_ip_ = new ::std::string;
  }
  root_ip_->assign(value);
}
inline void RespondStartFrameworkRoot::set_root_ip(const char* value, size_t size) {
  set_has_root_ip();
  if (root_ip_ == &::google::protobuf::internal::kEmptyString) {
    root_ip_ = new ::std::string;
  }
  root_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RespondStartFrameworkRoot::mutable_root_ip() {
  set_has_root_ip();
  if (root_ip_ == &::google::protobuf::internal::kEmptyString) {
    root_ip_ = new ::std::string;
  }
  return root_ip_;
}
inline ::std::string* RespondStartFrameworkRoot::release_root_ip() {
  clear_has_root_ip();
  if (root_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = root_ip_;
    root_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RespondStartFrameworkRoot::set_allocated_root_ip(::std::string* root_ip) {
  if (root_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete root_ip_;
  }
  if (root_ip) {
    set_has_root_ip();
    root_ip_ = root_ip;
  } else {
    clear_has_root_ip();
    root_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 root_PID = 3;
inline bool RespondStartFrameworkRoot::has_root_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RespondStartFrameworkRoot::set_has_root_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RespondStartFrameworkRoot::clear_has_root_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RespondStartFrameworkRoot::clear_root_pid() {
  root_pid_ = 0u;
  clear_has_root_pid();
}
inline ::google::protobuf::uint32 RespondStartFrameworkRoot::root_pid() const {
  return root_pid_;
}
inline void RespondStartFrameworkRoot::set_root_pid(::google::protobuf::uint32 value) {
  set_has_root_pid();
  root_pid_ = value;
}

// -------------------------------------------------------------------

// StartSlave

// required .RcNcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool StartSlave::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartSlave::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartSlave::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartSlave::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::RcNcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::RcNcProto::FrameworkInstanceInfo& StartSlave::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::RcNcProto::FrameworkInstanceInfo* StartSlave::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::RcNcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::RcNcProto::FrameworkInstanceInfo* StartSlave::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::RcNcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}
inline void StartSlave::set_allocated_framework_instance_info(::RcNcProto::FrameworkInstanceInfo* framework_instance_info) {
  delete framework_instance_info_;
  framework_instance_info_ = framework_instance_info;
  if (framework_instance_info) {
    set_has_framework_instance_info();
  } else {
    clear_has_framework_instance_info();
  }
}

// required uint32 self_module_id = 2;
inline bool StartSlave::has_self_module_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartSlave::set_has_self_module_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartSlave::clear_has_self_module_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartSlave::clear_self_module_id() {
  self_module_id_ = 0u;
  clear_has_self_module_id();
}
inline ::google::protobuf::uint32 StartSlave::self_module_id() const {
  return self_module_id_;
}
inline void StartSlave::set_self_module_id(::google::protobuf::uint32 value) {
  set_has_self_module_id();
  self_module_id_ = value;
}

// optional .RcNcProto.DockerImageInfo docker_image_info = 3;
inline bool StartSlave::has_docker_image_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartSlave::set_has_docker_image_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartSlave::clear_has_docker_image_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartSlave::clear_docker_image_info() {
  if (docker_image_info_ != NULL) docker_image_info_->::RcNcProto::DockerImageInfo::Clear();
  clear_has_docker_image_info();
}
inline const ::RcNcProto::DockerImageInfo& StartSlave::docker_image_info() const {
  return docker_image_info_ != NULL ? *docker_image_info_ : *default_instance_->docker_image_info_;
}
inline ::RcNcProto::DockerImageInfo* StartSlave::mutable_docker_image_info() {
  set_has_docker_image_info();
  if (docker_image_info_ == NULL) docker_image_info_ = new ::RcNcProto::DockerImageInfo;
  return docker_image_info_;
}
inline ::RcNcProto::DockerImageInfo* StartSlave::release_docker_image_info() {
  clear_has_docker_image_info();
  ::RcNcProto::DockerImageInfo* temp = docker_image_info_;
  docker_image_info_ = NULL;
  return temp;
}
inline void StartSlave::set_allocated_docker_image_info(::RcNcProto::DockerImageInfo* docker_image_info) {
  delete docker_image_info_;
  docker_image_info_ = docker_image_info;
  if (docker_image_info) {
    set_has_docker_image_info();
  } else {
    clear_has_docker_image_info();
  }
}

// optional .RcNcProto.ResourceInfo resource_info = 4;
inline bool StartSlave::has_resource_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartSlave::set_has_resource_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartSlave::clear_has_resource_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartSlave::clear_resource_info() {
  if (resource_info_ != NULL) resource_info_->::RcNcProto::ResourceInfo::Clear();
  clear_has_resource_info();
}
inline const ::RcNcProto::ResourceInfo& StartSlave::resource_info() const {
  return resource_info_ != NULL ? *resource_info_ : *default_instance_->resource_info_;
}
inline ::RcNcProto::ResourceInfo* StartSlave::mutable_resource_info() {
  set_has_resource_info();
  if (resource_info_ == NULL) resource_info_ = new ::RcNcProto::ResourceInfo;
  return resource_info_;
}
inline ::RcNcProto::ResourceInfo* StartSlave::release_resource_info() {
  clear_has_resource_info();
  ::RcNcProto::ResourceInfo* temp = resource_info_;
  resource_info_ = NULL;
  return temp;
}
inline void StartSlave::set_allocated_resource_info(::RcNcProto::ResourceInfo* resource_info) {
  delete resource_info_;
  resource_info_ = resource_info;
  if (resource_info) {
    set_has_resource_info();
  } else {
    clear_has_resource_info();
  }
}

// optional uint32 listen_port_num = 5;
inline bool StartSlave::has_listen_port_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartSlave::set_has_listen_port_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartSlave::clear_has_listen_port_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartSlave::clear_listen_port_num() {
  listen_port_num_ = 0u;
  clear_has_listen_port_num();
}
inline ::google::protobuf::uint32 StartSlave::listen_port_num() const {
  return listen_port_num_;
}
inline void StartSlave::set_listen_port_num(::google::protobuf::uint32 value) {
  set_has_listen_port_num();
  listen_port_num_ = value;
}

// optional .RcNcProto.NetAddress FM_master_net_address = 6;
inline bool StartSlave::has_fm_master_net_address() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StartSlave::set_has_fm_master_net_address() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StartSlave::clear_has_fm_master_net_address() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StartSlave::clear_fm_master_net_address() {
  if (fm_master_net_address_ != NULL) fm_master_net_address_->::RcNcProto::NetAddress::Clear();
  clear_has_fm_master_net_address();
}
inline const ::RcNcProto::NetAddress& StartSlave::fm_master_net_address() const {
  return fm_master_net_address_ != NULL ? *fm_master_net_address_ : *default_instance_->fm_master_net_address_;
}
inline ::RcNcProto::NetAddress* StartSlave::mutable_fm_master_net_address() {
  set_has_fm_master_net_address();
  if (fm_master_net_address_ == NULL) fm_master_net_address_ = new ::RcNcProto::NetAddress;
  return fm_master_net_address_;
}
inline ::RcNcProto::NetAddress* StartSlave::release_fm_master_net_address() {
  clear_has_fm_master_net_address();
  ::RcNcProto::NetAddress* temp = fm_master_net_address_;
  fm_master_net_address_ = NULL;
  return temp;
}
inline void StartSlave::set_allocated_fm_master_net_address(::RcNcProto::NetAddress* fm_master_net_address) {
  delete fm_master_net_address_;
  fm_master_net_address_ = fm_master_net_address;
  if (fm_master_net_address) {
    set_has_fm_master_net_address();
  } else {
    clear_has_fm_master_net_address();
  }
}

// optional .RcNcProto.NetAddress RC_net_address = 7;
inline bool StartSlave::has_rc_net_address() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StartSlave::set_has_rc_net_address() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StartSlave::clear_has_rc_net_address() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StartSlave::clear_rc_net_address() {
  if (rc_net_address_ != NULL) rc_net_address_->::RcNcProto::NetAddress::Clear();
  clear_has_rc_net_address();
}
inline const ::RcNcProto::NetAddress& StartSlave::rc_net_address() const {
  return rc_net_address_ != NULL ? *rc_net_address_ : *default_instance_->rc_net_address_;
}
inline ::RcNcProto::NetAddress* StartSlave::mutable_rc_net_address() {
  set_has_rc_net_address();
  if (rc_net_address_ == NULL) rc_net_address_ = new ::RcNcProto::NetAddress;
  return rc_net_address_;
}
inline ::RcNcProto::NetAddress* StartSlave::release_rc_net_address() {
  clear_has_rc_net_address();
  ::RcNcProto::NetAddress* temp = rc_net_address_;
  rc_net_address_ = NULL;
  return temp;
}
inline void StartSlave::set_allocated_rc_net_address(::RcNcProto::NetAddress* rc_net_address) {
  delete rc_net_address_;
  rc_net_address_ = rc_net_address;
  if (rc_net_address) {
    set_has_rc_net_address();
  } else {
    clear_has_rc_net_address();
  }
}

// -------------------------------------------------------------------

// RespondStartSlave

// required .RcNcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool RespondStartSlave::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespondStartSlave::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespondStartSlave::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespondStartSlave::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::RcNcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::RcNcProto::FrameworkInstanceInfo& RespondStartSlave::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::RcNcProto::FrameworkInstanceInfo* RespondStartSlave::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::RcNcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::RcNcProto::FrameworkInstanceInfo* RespondStartSlave::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::RcNcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}
inline void RespondStartSlave::set_allocated_framework_instance_info(::RcNcProto::FrameworkInstanceInfo* framework_instance_info) {
  delete framework_instance_info_;
  framework_instance_info_ = framework_instance_info;
  if (framework_instance_info) {
    set_has_framework_instance_info();
  } else {
    clear_has_framework_instance_info();
  }
}

// required uint32 self_module_id = 2;
inline bool RespondStartSlave::has_self_module_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespondStartSlave::set_has_self_module_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespondStartSlave::clear_has_self_module_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespondStartSlave::clear_self_module_id() {
  self_module_id_ = 0u;
  clear_has_self_module_id();
}
inline ::google::protobuf::uint32 RespondStartSlave::self_module_id() const {
  return self_module_id_;
}
inline void RespondStartSlave::set_self_module_id(::google::protobuf::uint32 value) {
  set_has_self_module_id();
  self_module_id_ = value;
}

// optional string machine_ip = 3;
inline bool RespondStartSlave::has_machine_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RespondStartSlave::set_has_machine_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RespondStartSlave::clear_has_machine_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RespondStartSlave::clear_machine_ip() {
  if (machine_ip_ != &::google::protobuf::internal::kEmptyString) {
    machine_ip_->clear();
  }
  clear_has_machine_ip();
}
inline const ::std::string& RespondStartSlave::machine_ip() const {
  return *machine_ip_;
}
inline void RespondStartSlave::set_machine_ip(const ::std::string& value) {
  set_has_machine_ip();
  if (machine_ip_ == &::google::protobuf::internal::kEmptyString) {
    machine_ip_ = new ::std::string;
  }
  machine_ip_->assign(value);
}
inline void RespondStartSlave::set_machine_ip(const char* value) {
  set_has_machine_ip();
  if (machine_ip_ == &::google::protobuf::internal::kEmptyString) {
    machine_ip_ = new ::std::string;
  }
  machine_ip_->assign(value);
}
inline void RespondStartSlave::set_machine_ip(const char* value, size_t size) {
  set_has_machine_ip();
  if (machine_ip_ == &::google::protobuf::internal::kEmptyString) {
    machine_ip_ = new ::std::string;
  }
  machine_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RespondStartSlave::mutable_machine_ip() {
  set_has_machine_ip();
  if (machine_ip_ == &::google::protobuf::internal::kEmptyString) {
    machine_ip_ = new ::std::string;
  }
  return machine_ip_;
}
inline ::std::string* RespondStartSlave::release_machine_ip() {
  clear_has_machine_ip();
  if (machine_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_ip_;
    machine_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RespondStartSlave::set_allocated_machine_ip(::std::string* machine_ip) {
  if (machine_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_ip_;
  }
  if (machine_ip) {
    set_has_machine_ip();
    machine_ip_ = machine_ip;
  } else {
    clear_has_machine_ip();
    machine_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 module_PID = 4;
inline bool RespondStartSlave::has_module_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RespondStartSlave::set_has_module_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RespondStartSlave::clear_has_module_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RespondStartSlave::clear_module_pid() {
  module_pid_ = 0u;
  clear_has_module_pid();
}
inline ::google::protobuf::uint32 RespondStartSlave::module_pid() const {
  return module_pid_;
}
inline void RespondStartSlave::set_module_pid(::google::protobuf::uint32 value) {
  set_has_module_pid();
  module_pid_ = value;
}

// -------------------------------------------------------------------

// FrameworkResourceInfo

// required .RcNcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool FrameworkResourceInfo::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkResourceInfo::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkResourceInfo::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkResourceInfo::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::RcNcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::RcNcProto::FrameworkInstanceInfo& FrameworkResourceInfo::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::RcNcProto::FrameworkInstanceInfo* FrameworkResourceInfo::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::RcNcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::RcNcProto::FrameworkInstanceInfo* FrameworkResourceInfo::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::RcNcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}
inline void FrameworkResourceInfo::set_allocated_framework_instance_info(::RcNcProto::FrameworkInstanceInfo* framework_instance_info) {
  delete framework_instance_info_;
  framework_instance_info_ = framework_instance_info;
  if (framework_instance_info) {
    set_has_framework_instance_info();
  } else {
    clear_has_framework_instance_info();
  }
}

// optional .RcNcProto.ResourceInfo resource_info = 2;
inline bool FrameworkResourceInfo::has_resource_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkResourceInfo::set_has_resource_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkResourceInfo::clear_has_resource_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkResourceInfo::clear_resource_info() {
  if (resource_info_ != NULL) resource_info_->::RcNcProto::ResourceInfo::Clear();
  clear_has_resource_info();
}
inline const ::RcNcProto::ResourceInfo& FrameworkResourceInfo::resource_info() const {
  return resource_info_ != NULL ? *resource_info_ : *default_instance_->resource_info_;
}
inline ::RcNcProto::ResourceInfo* FrameworkResourceInfo::mutable_resource_info() {
  set_has_resource_info();
  if (resource_info_ == NULL) resource_info_ = new ::RcNcProto::ResourceInfo;
  return resource_info_;
}
inline ::RcNcProto::ResourceInfo* FrameworkResourceInfo::release_resource_info() {
  clear_has_resource_info();
  ::RcNcProto::ResourceInfo* temp = resource_info_;
  resource_info_ = NULL;
  return temp;
}
inline void FrameworkResourceInfo::set_allocated_resource_info(::RcNcProto::ResourceInfo* resource_info) {
  delete resource_info_;
  resource_info_ = resource_info;
  if (resource_info) {
    set_has_resource_info();
  } else {
    clear_has_resource_info();
  }
}

// optional uint32 module_PID = 3;
inline bool FrameworkResourceInfo::has_module_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameworkResourceInfo::set_has_module_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrameworkResourceInfo::clear_has_module_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrameworkResourceInfo::clear_module_pid() {
  module_pid_ = 0u;
  clear_has_module_pid();
}
inline ::google::protobuf::uint32 FrameworkResourceInfo::module_pid() const {
  return module_pid_;
}
inline void FrameworkResourceInfo::set_module_pid(::google::protobuf::uint32 value) {
  set_has_module_pid();
  module_pid_ = value;
}

// -------------------------------------------------------------------

// CloseModule

// required .RcNcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool CloseModule::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseModule::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseModule::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseModule::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::RcNcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::RcNcProto::FrameworkInstanceInfo& CloseModule::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::RcNcProto::FrameworkInstanceInfo* CloseModule::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::RcNcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::RcNcProto::FrameworkInstanceInfo* CloseModule::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::RcNcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}
inline void CloseModule::set_allocated_framework_instance_info(::RcNcProto::FrameworkInstanceInfo* framework_instance_info) {
  delete framework_instance_info_;
  framework_instance_info_ = framework_instance_info;
  if (framework_instance_info) {
    set_has_framework_instance_info();
  } else {
    clear_has_framework_instance_info();
  }
}

// repeated uint32 module_PID = 2;
inline int CloseModule::module_pid_size() const {
  return module_pid_.size();
}
inline void CloseModule::clear_module_pid() {
  module_pid_.Clear();
}
inline ::google::protobuf::uint32 CloseModule::module_pid(int index) const {
  return module_pid_.Get(index);
}
inline void CloseModule::set_module_pid(int index, ::google::protobuf::uint32 value) {
  module_pid_.Set(index, value);
}
inline void CloseModule::add_module_pid(::google::protobuf::uint32 value) {
  module_pid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CloseModule::module_pid() const {
  return module_pid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CloseModule::mutable_module_pid() {
  return &module_pid_;
}

// -------------------------------------------------------------------

// MachineResourceInfo

// required uint32 cpu_mem_size = 1;
inline bool MachineResourceInfo::has_cpu_mem_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MachineResourceInfo::set_has_cpu_mem_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MachineResourceInfo::clear_has_cpu_mem_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MachineResourceInfo::clear_cpu_mem_size() {
  cpu_mem_size_ = 0u;
  clear_has_cpu_mem_size();
}
inline ::google::protobuf::uint32 MachineResourceInfo::cpu_mem_size() const {
  return cpu_mem_size_;
}
inline void MachineResourceInfo::set_cpu_mem_size(::google::protobuf::uint32 value) {
  set_has_cpu_mem_size();
  cpu_mem_size_ = value;
}

// optional double cpu_num = 2;
inline bool MachineResourceInfo::has_cpu_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MachineResourceInfo::set_has_cpu_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MachineResourceInfo::clear_has_cpu_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MachineResourceInfo::clear_cpu_num() {
  cpu_num_ = 0;
  clear_has_cpu_num();
}
inline double MachineResourceInfo::cpu_num() const {
  return cpu_num_;
}
inline void MachineResourceInfo::set_cpu_num(double value) {
  set_has_cpu_num();
  cpu_num_ = value;
}

// optional uint32 net_speed = 3;
inline bool MachineResourceInfo::has_net_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MachineResourceInfo::set_has_net_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MachineResourceInfo::clear_has_net_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MachineResourceInfo::clear_net_speed() {
  net_speed_ = 0u;
  clear_has_net_speed();
}
inline ::google::protobuf::uint32 MachineResourceInfo::net_speed() const {
  return net_speed_;
}
inline void MachineResourceInfo::set_net_speed(::google::protobuf::uint32 value) {
  set_has_net_speed();
  net_speed_ = value;
}

// optional uint32 disk_size = 4;
inline bool MachineResourceInfo::has_disk_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MachineResourceInfo::set_has_disk_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MachineResourceInfo::clear_has_disk_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MachineResourceInfo::clear_disk_size() {
  disk_size_ = 0u;
  clear_has_disk_size();
}
inline ::google::protobuf::uint32 MachineResourceInfo::disk_size() const {
  return disk_size_;
}
inline void MachineResourceInfo::set_disk_size(::google::protobuf::uint32 value) {
  set_has_disk_size();
  disk_size_ = value;
}

// optional uint32 gpu_num = 5;
inline bool MachineResourceInfo::has_gpu_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MachineResourceInfo::set_has_gpu_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MachineResourceInfo::clear_has_gpu_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MachineResourceInfo::clear_gpu_num() {
  gpu_num_ = 0u;
  clear_has_gpu_num();
}
inline ::google::protobuf::uint32 MachineResourceInfo::gpu_num() const {
  return gpu_num_;
}
inline void MachineResourceInfo::set_gpu_num(::google::protobuf::uint32 value) {
  set_has_gpu_num();
  gpu_num_ = value;
}

// repeated .RcNcProto.GpuResourceInfo gpu_resource_info = 6;
inline int MachineResourceInfo::gpu_resource_info_size() const {
  return gpu_resource_info_.size();
}
inline void MachineResourceInfo::clear_gpu_resource_info() {
  gpu_resource_info_.Clear();
}
inline const ::RcNcProto::GpuResourceInfo& MachineResourceInfo::gpu_resource_info(int index) const {
  return gpu_resource_info_.Get(index);
}
inline ::RcNcProto::GpuResourceInfo* MachineResourceInfo::mutable_gpu_resource_info(int index) {
  return gpu_resource_info_.Mutable(index);
}
inline ::RcNcProto::GpuResourceInfo* MachineResourceInfo::add_gpu_resource_info() {
  return gpu_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RcNcProto::GpuResourceInfo >&
MachineResourceInfo::gpu_resource_info() const {
  return gpu_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::RcNcProto::GpuResourceInfo >*
MachineResourceInfo::mutable_gpu_resource_info() {
  return &gpu_resource_info_;
}

// -------------------------------------------------------------------

// ContainerResourceInfo

// required uint32 framework_instance_id = 1;
inline bool ContainerResourceInfo::has_framework_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerResourceInfo::set_has_framework_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerResourceInfo::clear_has_framework_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerResourceInfo::clear_framework_instance_id() {
  framework_instance_id_ = 0u;
  clear_has_framework_instance_id();
}
inline ::google::protobuf::uint32 ContainerResourceInfo::framework_instance_id() const {
  return framework_instance_id_;
}
inline void ContainerResourceInfo::set_framework_instance_id(::google::protobuf::uint32 value) {
  set_has_framework_instance_id();
  framework_instance_id_ = value;
}

// optional .RcNcProto.ResourceInfo resource_info = 2;
inline bool ContainerResourceInfo::has_resource_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerResourceInfo::set_has_resource_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerResourceInfo::clear_has_resource_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerResourceInfo::clear_resource_info() {
  if (resource_info_ != NULL) resource_info_->::RcNcProto::ResourceInfo::Clear();
  clear_has_resource_info();
}
inline const ::RcNcProto::ResourceInfo& ContainerResourceInfo::resource_info() const {
  return resource_info_ != NULL ? *resource_info_ : *default_instance_->resource_info_;
}
inline ::RcNcProto::ResourceInfo* ContainerResourceInfo::mutable_resource_info() {
  set_has_resource_info();
  if (resource_info_ == NULL) resource_info_ = new ::RcNcProto::ResourceInfo;
  return resource_info_;
}
inline ::RcNcProto::ResourceInfo* ContainerResourceInfo::release_resource_info() {
  clear_has_resource_info();
  ::RcNcProto::ResourceInfo* temp = resource_info_;
  resource_info_ = NULL;
  return temp;
}
inline void ContainerResourceInfo::set_allocated_resource_info(::RcNcProto::ResourceInfo* resource_info) {
  delete resource_info_;
  resource_info_ = resource_info;
  if (resource_info) {
    set_has_resource_info();
  } else {
    clear_has_resource_info();
  }
}

// -------------------------------------------------------------------

// MonitorInfo

// required .RcNcProto.MachineResourceInfo total_machine_resource_info = 1;
inline bool MonitorInfo::has_total_machine_resource_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MonitorInfo::set_has_total_machine_resource_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MonitorInfo::clear_has_total_machine_resource_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MonitorInfo::clear_total_machine_resource_info() {
  if (total_machine_resource_info_ != NULL) total_machine_resource_info_->::RcNcProto::MachineResourceInfo::Clear();
  clear_has_total_machine_resource_info();
}
inline const ::RcNcProto::MachineResourceInfo& MonitorInfo::total_machine_resource_info() const {
  return total_machine_resource_info_ != NULL ? *total_machine_resource_info_ : *default_instance_->total_machine_resource_info_;
}
inline ::RcNcProto::MachineResourceInfo* MonitorInfo::mutable_total_machine_resource_info() {
  set_has_total_machine_resource_info();
  if (total_machine_resource_info_ == NULL) total_machine_resource_info_ = new ::RcNcProto::MachineResourceInfo;
  return total_machine_resource_info_;
}
inline ::RcNcProto::MachineResourceInfo* MonitorInfo::release_total_machine_resource_info() {
  clear_has_total_machine_resource_info();
  ::RcNcProto::MachineResourceInfo* temp = total_machine_resource_info_;
  total_machine_resource_info_ = NULL;
  return temp;
}
inline void MonitorInfo::set_allocated_total_machine_resource_info(::RcNcProto::MachineResourceInfo* total_machine_resource_info) {
  delete total_machine_resource_info_;
  total_machine_resource_info_ = total_machine_resource_info;
  if (total_machine_resource_info) {
    set_has_total_machine_resource_info();
  } else {
    clear_has_total_machine_resource_info();
  }
}

// optional .RcNcProto.MachineResourceInfo usage_machine_resource_info = 2;
inline bool MonitorInfo::has_usage_machine_resource_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MonitorInfo::set_has_usage_machine_resource_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MonitorInfo::clear_has_usage_machine_resource_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MonitorInfo::clear_usage_machine_resource_info() {
  if (usage_machine_resource_info_ != NULL) usage_machine_resource_info_->::RcNcProto::MachineResourceInfo::Clear();
  clear_has_usage_machine_resource_info();
}
inline const ::RcNcProto::MachineResourceInfo& MonitorInfo::usage_machine_resource_info() const {
  return usage_machine_resource_info_ != NULL ? *usage_machine_resource_info_ : *default_instance_->usage_machine_resource_info_;
}
inline ::RcNcProto::MachineResourceInfo* MonitorInfo::mutable_usage_machine_resource_info() {
  set_has_usage_machine_resource_info();
  if (usage_machine_resource_info_ == NULL) usage_machine_resource_info_ = new ::RcNcProto::MachineResourceInfo;
  return usage_machine_resource_info_;
}
inline ::RcNcProto::MachineResourceInfo* MonitorInfo::release_usage_machine_resource_info() {
  clear_has_usage_machine_resource_info();
  ::RcNcProto::MachineResourceInfo* temp = usage_machine_resource_info_;
  usage_machine_resource_info_ = NULL;
  return temp;
}
inline void MonitorInfo::set_allocated_usage_machine_resource_info(::RcNcProto::MachineResourceInfo* usage_machine_resource_info) {
  delete usage_machine_resource_info_;
  usage_machine_resource_info_ = usage_machine_resource_info;
  if (usage_machine_resource_info) {
    set_has_usage_machine_resource_info();
  } else {
    clear_has_usage_machine_resource_info();
  }
}

// optional .RcNcProto.ResourceInfo rest_machine_resource_info = 3;
inline bool MonitorInfo::has_rest_machine_resource_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MonitorInfo::set_has_rest_machine_resource_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MonitorInfo::clear_has_rest_machine_resource_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MonitorInfo::clear_rest_machine_resource_info() {
  if (rest_machine_resource_info_ != NULL) rest_machine_resource_info_->::RcNcProto::ResourceInfo::Clear();
  clear_has_rest_machine_resource_info();
}
inline const ::RcNcProto::ResourceInfo& MonitorInfo::rest_machine_resource_info() const {
  return rest_machine_resource_info_ != NULL ? *rest_machine_resource_info_ : *default_instance_->rest_machine_resource_info_;
}
inline ::RcNcProto::ResourceInfo* MonitorInfo::mutable_rest_machine_resource_info() {
  set_has_rest_machine_resource_info();
  if (rest_machine_resource_info_ == NULL) rest_machine_resource_info_ = new ::RcNcProto::ResourceInfo;
  return rest_machine_resource_info_;
}
inline ::RcNcProto::ResourceInfo* MonitorInfo::release_rest_machine_resource_info() {
  clear_has_rest_machine_resource_info();
  ::RcNcProto::ResourceInfo* temp = rest_machine_resource_info_;
  rest_machine_resource_info_ = NULL;
  return temp;
}
inline void MonitorInfo::set_allocated_rest_machine_resource_info(::RcNcProto::ResourceInfo* rest_machine_resource_info) {
  delete rest_machine_resource_info_;
  rest_machine_resource_info_ = rest_machine_resource_info;
  if (rest_machine_resource_info) {
    set_has_rest_machine_resource_info();
  } else {
    clear_has_rest_machine_resource_info();
  }
}

// repeated .RcNcProto.ContainerResourceInfo container_require_resource_info = 4;
inline int MonitorInfo::container_require_resource_info_size() const {
  return container_require_resource_info_.size();
}
inline void MonitorInfo::clear_container_require_resource_info() {
  container_require_resource_info_.Clear();
}
inline const ::RcNcProto::ContainerResourceInfo& MonitorInfo::container_require_resource_info(int index) const {
  return container_require_resource_info_.Get(index);
}
inline ::RcNcProto::ContainerResourceInfo* MonitorInfo::mutable_container_require_resource_info(int index) {
  return container_require_resource_info_.Mutable(index);
}
inline ::RcNcProto::ContainerResourceInfo* MonitorInfo::add_container_require_resource_info() {
  return container_require_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RcNcProto::ContainerResourceInfo >&
MonitorInfo::container_require_resource_info() const {
  return container_require_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::RcNcProto::ContainerResourceInfo >*
MonitorInfo::mutable_container_require_resource_info() {
  return &container_require_resource_info_;
}

// repeated .RcNcProto.ContainerResourceInfo container_usage_resource_info = 5;
inline int MonitorInfo::container_usage_resource_info_size() const {
  return container_usage_resource_info_.size();
}
inline void MonitorInfo::clear_container_usage_resource_info() {
  container_usage_resource_info_.Clear();
}
inline const ::RcNcProto::ContainerResourceInfo& MonitorInfo::container_usage_resource_info(int index) const {
  return container_usage_resource_info_.Get(index);
}
inline ::RcNcProto::ContainerResourceInfo* MonitorInfo::mutable_container_usage_resource_info(int index) {
  return container_usage_resource_info_.Mutable(index);
}
inline ::RcNcProto::ContainerResourceInfo* MonitorInfo::add_container_usage_resource_info() {
  return container_usage_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RcNcProto::ContainerResourceInfo >&
MonitorInfo::container_usage_resource_info() const {
  return container_usage_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::RcNcProto::ContainerResourceInfo >*
MonitorInfo::mutable_container_usage_resource_info() {
  return &container_usage_resource_info_;
}

// repeated uint32 crash_moudle_id = 6;
inline int MonitorInfo::crash_moudle_id_size() const {
  return crash_moudle_id_.size();
}
inline void MonitorInfo::clear_crash_moudle_id() {
  crash_moudle_id_.Clear();
}
inline ::google::protobuf::uint32 MonitorInfo::crash_moudle_id(int index) const {
  return crash_moudle_id_.Get(index);
}
inline void MonitorInfo::set_crash_moudle_id(int index, ::google::protobuf::uint32 value) {
  crash_moudle_id_.Set(index, value);
}
inline void MonitorInfo::add_crash_moudle_id(::google::protobuf::uint32 value) {
  crash_moudle_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MonitorInfo::crash_moudle_id() const {
  return crash_moudle_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MonitorInfo::mutable_crash_moudle_id() {
  return &crash_moudle_id_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace RcNcProto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RcNcProtocol_2eproto__INCLUDED
